I"0<h1 id="c-变量判定的螺旋法则">C++ 变量判定的螺旋法则</h1>

<p>C++ 中一个标识符配合着各种修饰界定符，使得标识符的本意不那么直观一眼就能看出，甚至需要仔细分析，才能知道该标识符的具体你含义。</p>

<p>比如：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">signal</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="kt">int</span><span class="p">)))(</span><span class="kt">int</span><span class="p">);</span>
</code></pre></div></div>

<p>其中 <code class="language-plaintext highlighter-rouge">signal</code> 是什么？</p>

<h2 id="螺旋法则">螺旋法则</h2>

<p>对于如何进行变量的辩识，有个非官方的 “顺时针/螺旋法则（Clockwise/Spiral Rule）” 可用来帮助辩识。</p>

<p>该法则的内容，简单来说，为了搞清楚一个未知标识符的含义，我们可以：</p>

<ol>
  <li>从我们需要判定的标识符开始，顺时针画圈，遇到如下符号时，用对应的语义替换：
    <ul>
      <li><code class="language-plaintext highlighter-rouge">[x]</code> 或 <code class="language-plaintext highlighter-rouge">[]</code> =&gt; 容量为 <code class="language-plaintext highlighter-rouge">x</code> 的数组或数组</li>
      <li><code class="language-plaintext highlighter-rouge">(type1,type2...)</code> =&gt; 接收 <code class="language-plaintext highlighter-rouge">type1</code>、<code class="language-plaintext highlighter-rouge">type2</code>... 的函数，返回值为（待定）</li>
      <li><code class="language-plaintext highlighter-rouge">*</code> =&gt; 指向（类型待定）的指针</li>
    </ul>
  </li>
  <li>重复上面的步骤直到语句中所有符号都被遍历过。</li>
  <li>始终优先解析括号括起来的部分。</li>
</ol>

<h2 id="实地演练">实地演练</h2>

<h3 id="一个简单的示例">一个简单的示例</h3>

<p>先从一个简单的开始，判定如下语句中 <code class="language-plaintext highlighter-rouge">str</code> 的含义：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                     <span class="o">+-------+</span>
                     <span class="o">|</span> <span class="o">+-+</span>   <span class="o">|</span>
                     <span class="o">|</span> <span class="o">^</span> <span class="o">|</span>   <span class="o">|</span>
                <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
                 <span class="o">^</span>   <span class="o">^</span>   <span class="o">|</span>   <span class="o">|</span>
                 <span class="o">|</span>   <span class="o">+---+</span>   <span class="o">|</span>
                 <span class="o">+-----------+</span>
</code></pre></div></div>

<p>根据螺旋法则，如上面线图标识所示，</p>
<ul>
  <li>从 <code class="language-plaintext highlighter-rouge">str</code> 这个需要被判定的对象出发。</li>
  <li>螺旋路径上第一次遇到的是 <code class="language-plaintext highlighter-rouge">[</code> 左方括号，由此我们知道，<code class="language-plaintext highlighter-rouge">str</code> 是一个尺寸为 10 的数组。</li>
  <li>继续旋转，遇到 <code class="language-plaintext highlighter-rouge">*</code>，所以 <code class="language-plaintext highlighter-rouge">str</code> 是一个尺寸为 10 的数组，数组元素为指针。</li>
  <li>继续，遇到 <code class="language-plaintext highlighter-rouge">;</code> 标识语句的结束。</li>
  <li>再继续，遇到 <code class="language-plaintext highlighter-rouge">char</code>，所以 <code class="language-plaintext highlighter-rouge">str</code> 是一个尺寸为 10 的数组，数组元素为指向 <code class="language-plaintext highlighter-rouge">char</code> 类型的指针。</li>
</ul>

<h3 id="进阶">进阶</h3>

<p>回到文章开头那个语句，来判定其中 <code class="language-plaintext highlighter-rouge">signal</code> 的含义。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                      <span class="o">+-----------------------------+</span>
                      <span class="o">|</span>                  <span class="o">+---+</span>      <span class="o">|</span>
                      <span class="o">|</span>  <span class="o">+---+</span>           <span class="o">|+-+|</span>      <span class="o">|</span>
                      <span class="o">|</span>  <span class="o">^</span>   <span class="o">|</span>           <span class="o">|^</span> <span class="o">||</span>      <span class="o">|</span>
                <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">signal</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">fp</span><span class="p">)(</span><span class="kt">int</span><span class="p">)))(</span><span class="kt">int</span><span class="p">);</span>
                 <span class="o">^</span>    <span class="o">^</span>      <span class="o">|</span>      <span class="o">^</span>    <span class="o">^</span>  <span class="o">||</span>      <span class="o">|</span>
                 <span class="o">|</span>    <span class="o">+------+</span>      <span class="o">|</span>    <span class="o">+--+|</span>      <span class="o">|</span>
                 <span class="o">|</span>                  <span class="o">+--------+</span>      <span class="o">|</span>
                 <span class="o">+----------------------------------+</span>
</code></pre></div></div>

<p>由螺旋法则画出如上的线图，进而可分析：</p>

<ul>
  <li>从要判定的 <code class="language-plaintext highlighter-rouge">signal</code> 出发首次遇到 <code class="language-plaintext highlighter-rouge">(</code> 左括号，表示 <code class="language-plaintext highlighter-rouge">signal</code> 是一个函数，入参为 <code class="language-plaintext highlighter-rouge">int</code> 和 ...</li>
  <li>此处需要需要进一步运用螺旋法则先确定 <code class="language-plaintext highlighter-rouge">fp</code> 的含义，才能进而确认 <code class="language-plaintext highlighter-rouge">signal</code> 这个函数的完整入参。所以从 <code class="language-plaintext highlighter-rouge">fp</code> 了发进行一次子螺旋。</li>
  <li>因为需要优先解析括号括起来的部分，所以转一圈回来首次遇到的是 <code class="language-plaintext highlighter-rouge">*</code>，由此 <code class="language-plaintext highlighter-rouge">fp</code> 是一个指针。</li>
  <li>继续解析 <code class="language-plaintext highlighter-rouge">fp</code>，遇到 <code class="language-plaintext highlighter-rouge">(</code>，所以 <code class="language-plaintext highlighter-rouge">fp</code> 是一个指向函数的指针，这个函数接收一个 <code class="language-plaintext highlighter-rouge">int</code> 类型的入参。</li>
  <li>继续下去，遇到 <code class="language-plaintext highlighter-rouge">void</code>，所以 <code class="language-plaintext highlighter-rouge">fp</code> 是一个指向函数的指针，这个函数接收一个 <code class="language-plaintext highlighter-rouge">int</code> 类型的入参并且返回值为空。</li>
  <li>至此完成了 <code class="language-plaintext highlighter-rouge">fp</code> 的解析，可以知道 <code class="language-plaintext highlighter-rouge">signal</code> 的类型为：
    <ul>
      <li>是一个函数，入参为：
        <ul>
          <li>一个 int 类型</li>
          <li>一个指向函数的指针，这个函数接收一个 <code class="language-plaintext highlighter-rouge">int</code> 类型的入参并且返回值为空</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>路径跑到 <code class="language-plaintext highlighter-rouge">signal</code> 的螺旋中，遇到 <code class="language-plaintext highlighter-rouge">*</code>（紧邻 <code class="language-plaintext highlighter-rouge">signal</code> 左边），所以 <code class="language-plaintext highlighter-rouge">signal</code> 是
    <ul>
      <li>一个函数，入参为：
        <ul>
          <li>一个 int 类型</li>
          <li>一个指向函数的指针，这个函数接收一个 <code class="language-plaintext highlighter-rouge">int</code> 类型的入参并且返回值为空</li>
        </ul>
      </li>
      <li>返回值为指针</li>
    </ul>
  </li>
  <li>再继续，遇到 <code class="language-plaintext highlighter-rouge">(</code>，接上面，返回值为指向另一函数的指针，被指向的这个函数接收一个 <code class="language-plaintext highlighter-rouge">int</code> 入参。</li>
  <li>最后，遇到 <code class="language-plaintext highlighter-rouge">void</code>，<code class="language-plaintext highlighter-rouge">signal</code> 返回值指向的这个函数的返回值为空。</li>
</ul>

<p>最后捋一下 <code class="language-plaintext highlighter-rouge">signal</code> 的完整类型为：接收一个 <code class="language-plaintext highlighter-rouge">int</code>，一个指向接收一个 <code class="language-plaintext highlighter-rouge">int</code> 并且返回值为空的函数的指针，这两个参数的函数，并且返回值为指向一个接收 <code class="language-plaintext highlighter-rouge">int</code> 型返回为空的函数...Orz。</p>

<h3 id="成员函数的判定">成员函数的判定</h3>

<p>螺旋施法没有给出在 <code class="language-plaintext highlighter-rouge">const</code> 参与的情况下的判定，不过<strong>因为 <code class="language-plaintext highlighter-rouge">const</code> 默认修饰紧邻其左边的元素，如果右边无元素，则修饰左边的元素</strong>。因此只需要将 const 和它修饰的元素作为整体来看，就还是可以使用螺旋法则的。</p>

<p>考察如下语句：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="k">const</span> <span class="n">Method3</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">*</span><span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</code></pre></div></div>
<p>当函数后面紧跟一个 <code class="language-plaintext highlighter-rouge">const</code> 时，表示该成员函数的作用域内 <code class="language-plaintext highlighter-rouge">*this</code> 是常量，即无法在该函数体内对所类的实体进行修改。</p>

<p>下面对上面的语句进行分析：</p>

<ul>
  <li>从 <code class="language-plaintext highlighter-rouge">Method3</code> 出发，遇到 <code class="language-plaintext highlighter-rouge">(</code>，所以 <code class="language-plaintext highlighter-rouge">Method3</code> 是一个函数，接收一个引用作为入参 <code class="language-plaintext highlighter-rouge">const int*const&amp;</code> 部分。</li>
  <li>该引用的类型是 <code class="language-plaintext highlighter-rouge">const int*const</code>，指向整形常量的常量指针。</li>
  <li>继续遇到 <code class="language-plaintext highlighter-rouge">*const</code>，所以函数的返回值为常量指针。指针指向的类型为 <code class="language-plaintext highlighter-rouge">const int</code> 整形常量。</li>
  <li>函数末尾的 <code class="language-plaintext highlighter-rouge">const</code> 如前所述，标识函数体内不修改实例。</li>
</ul>

<h2 id="相关资源">相关资源</h2>

<ul>
  <li><a href="http://c-faq.com/decl/spiral.anderson.html">The ``Clockwise/Spiral Rule’’</a></li>
  <li><a href="http://duramecho.com/ComputerInformation/WhyHowCppConst.html">The C++ ‘const’ Declaration: Why &amp; How</a></li>
</ul>

:ET