I"$#<h1 id="react-controlled-及-uncontrolled-组件">React <code class="language-plaintext highlighter-rouge">controlled</code> 及 <code class="language-plaintext highlighter-rouge">uncontrolled</code> 组件</h1>

<p>通过 <code class="language-plaintext highlighter-rouge">props</code> 来设置其 <code class="language-plaintext highlighter-rouge">value</code> 值的组件便是一种 <code class="language-plaintext highlighter-rouge">controlled</code> 组件。典型的 form 表单中，像</p>

<ul>
  <li>输入框 <code class="language-plaintext highlighter-rouge">&lt;input&gt;</code></li>
  <li>下拉框 <code class="language-plaintext highlighter-rouge">&lt;select&gt;</code></li>
  <li>多选框 <code class="language-plaintext highlighter-rouge">&lt;input type="checkbox"&gt;</code></li>
  <li>单选框 <code class="language-plaintext highlighter-rouge">&lt;input type="radio"&gt;</code></li>
  <li>文本框 <code class="language-plaintext highlighter-rouge">&lt;textarea&gt;</code></li>
</ul>

<p>这些，都可通过 <code class="language-plaintext highlighter-rouge">props</code> 来设置初始值，同时通过监听其身上的 <code class="language-plaintext highlighter-rouge">onChanges</code> 事件来将最新的值回传到 React 中。这样，组件的值便始终与 React 中的状态是同步的。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Form</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">();</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">name</span><span class="p">:</span> <span class="dl">''</span><span class="p">,</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="nx">handleNameChange</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="na">name</span><span class="p">:</span> <span class="nx">event</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span> <span class="p">});</span>
  <span class="p">};</span>

  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">input</span>
          <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">text</span><span class="dl">"</span>
          <span class="nx">value</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span>
          <span class="nx">onChange</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleNameChange</span><span class="p">}</span>
        <span class="sr">/</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如上， <code class="language-plaintext highlighter-rouge">controlled</code> 类型的组件需要在组件中有对应的 <code class="language-plaintext highlighter-rouge">state</code> 来保存相应的值。同时需要为组件编写值更新后的监听逻辑。</p>

<p>对应的 <code class="language-plaintext highlighter-rouge">uncontrolled</code> 类型，便方便得多，它其实就是普通的 HTML 标签。</p>

<p>对于 <code class="language-plaintext highlighter-rouge">uncontrolled</code> 类型的组件，通过 ref 来获取它身上的 <code class="language-plaintext highlighter-rouge">value</code> 值。</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Form</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">handleSubmitClick</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">_name</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
    <span class="c1">// do something with `name`</span>
  <span class="p">}</span>

  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="nx">input</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">text</span><span class="dl">"</span> <span class="nx">ref</span><span class="o">=</span><span class="p">{</span><span class="nx">input</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">_name</span> <span class="o">=</span> <span class="nx">input</span><span class="p">}</span> <span class="sr">/</span><span class="err">&gt;
</span>        <span class="o">&lt;</span><span class="nx">button</span> <span class="nx">onClick</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleSubmitClick</span><span class="p">}</span><span class="o">&gt;</span><span class="nx">Sign</span> <span class="nx">up</span><span class="o">&lt;</span><span class="sr">/button</span><span class="err">&gt;
</span>      <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span>    <span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>可以看出，<code class="language-plaintext highlighter-rouge">uncontorlled</code> 类型的组件，其值是存储在 DOM 节点上的，在需要的时候，比如表单提交时，再通过 ref 获取到相应的 DOM 节点取出它的值。</p>

<p>对比之下，<code class="language-plaintext highlighter-rouge">controlled</code> 类型的组件是时实地将最新的值推送（push）到 React 中，而 <code class="language-plaintext highlighter-rouge">uncontrolled</code> 类型的组件是在需要的时候去拉取（pull）它身上的值。</p>

<h2 id="对比与取舍">对比与取舍</h2>

<p>虽然 <code class="language-plaintext highlighter-rouge">ref</code> 在官方文档中是不推荐的，也不代表说 <code class="language-plaintext highlighter-rouge">uncontrolled</code> 类型的组件就不能使用；虽然 <code class="language-plaintext highlighter-rouge">controlled</code> 类型的组件这种，数据走 state 更新和维护的方式，更加 React 一点，也不是说在编写表单时就需要全部使用 <code class="language-plaintext highlighter-rouge">controlled</code> 类型的组件。两者在不同情况下可以自由取舍，完全看需要。</p>

<p><code class="language-plaintext highlighter-rouge">controlled</code> 类型的组件虽然写起来会比较麻烦，其值与 React state 始终同步，所以有一些优点，</p>

<ul>
  <li>很方便地对用户输入的值进行校验，然后展示相应的错误信息。</li>
  <li>可以时实地格式化用的输入，对于特定类型的值比如信用卡，手机等。</li>
  <li>根据用户的填写情况时实将表单的提交按钮禁用或启用。</li>
</ul>

<p>所以如果需要上述这些东西，可以考虑 <code class="language-plaintext highlighter-rouge">controlled</code> 类型来编写组件，而 <code class="language-plaintext highlighter-rouge">uncontrolled</code> 类型代码上写起来很简洁点，少了 state 及事件绑定，可用在功能简单，或者 React 快速上手，快速实现功能的场景。</p>

<h2 id="相关资源">相关资源</h2>

<ul>
  <li><a href="https://reactjs.org/docs/forms.html">Forms</a></li>
  <li><a href="https://reactjs.org/docs/uncontrolled-components.html">Uncontrolled Components</a></li>
  <li><a href="https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/">Controlled and uncontrolled form inputs in React don’t have to be complicated</a></li>
</ul>

:ET