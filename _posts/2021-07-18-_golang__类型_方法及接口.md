---
layout: post
title: "[golang] ç±»å‹ï¼Œæ–¹æ³•åŠæ¥å£"
date: 2021-07-18T02:38:49Z
---
# [golang] ç±»å‹ï¼Œæ–¹æ³•åŠæ¥å£

## Type

å¸¸è§çš„å°±æ˜¯é€šè¿‡ `type` å®šä¹‰ç»“æ„ä½“ï¼Œé™¤æ­¤ä¹‹å¤–ï¼Œè¿˜å¯å¯¹åŸå§‹å€¼ç±»å‹åŠå„ç§å¤åˆç±»å‹è¿›è¡Œåˆ«åè®¾ç½®ã€‚

```go
type Person struct {
	Name string
	Age  int
}

type Score int

type Convert func(string) Score
```

ä¸€äº›æ¦‚å¿µ

- abstract type:  å®šä¹‰ä¸€ç§ç±»å‹åšä»€ä¹ˆï¼Œä½†ä¸åŒ…å«å…·ä½“æ€æ ·åš
- concrete type: å®šä¹‰ä¸€ç§ç±»å‹åšä»€ä¹ˆåŠå¦‚ä½•åš

## Methods

è·Ÿç±»å‹ç»‘å®šçš„æ–¹æ³•ï¼Œä¸æ™®é€šå‡½æ•°å£°æ˜å·®ä¸å¤šï¼Œåªæ˜¯å¤šå‡ºäº†ä¸ª receiver éƒ¨åˆ†ã€‚receiver éƒ¨åˆ†çº¦å®šä»¥ç±»å‹é¦–å­—æ¯å°å†™å‘½åï¼Œè€Œä¸ç”¨ `this` æˆ– `self`ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªä½¿ç”¨ç¤ºä¾‹ï¼š

```go
type Person struct {
	Name string
	Age  int
}

func (p Person) String() string {
	return fmt.Sprintf("name: %s, age:%d", p.Name, p.Age)
}

func main() {
	p := Person{
		Name: "foo",
		Age:  11,
	}
	fmt.Println(p.String())
}
```

## æŒ‡é’ˆ receiver

åƒæ™®é€šå‡½æ•°ä¸€æ ·ï¼Œä½¿ç”¨æŒ‡é’ˆä½œä¸ºå…¥å‚æ ‡è¯†å‡½æ•°ä¸­éœ€è¦å¯¹å…¥å‚è¿›è¡Œä¿®æ”¹ï¼Œè¿™é‡Œ methods ä¹Ÿä¸€æ ·ã€‚ä»¥ä¸‹æƒ…å†µ methods éœ€è¦ä½¿ç”¨æŒ‡é’ˆå…¥å‚ï¼š

- å¦‚æœæ–¹æ³•è¦ä¿®æ”¹ receiver
- å¦‚æœæ–¹æ³•ä¸­éœ€è¦å¤„ç† `nil` ç©ºå®ä¾‹

å…¶ä»–æƒ…å†µï¼Œæ¯”å¦‚ä¸éœ€è¦åœ¨ä¿®æ”¹ receiver æ—¶ï¼Œå¯ä½¿ç”¨å€¼ç±»å‹è€Œä¸æ˜¯æŒ‡é’ˆç±»å‹ã€‚

ä½†ï¼Œæœ€ä½³å®è·µæ˜¯è¿™æ ·çš„ï¼šä¸€ä¸ªæ–¹æ³•æ˜¯å¦ä½¿ç”¨å€¼ç±»å‹ï¼Œè¿˜è¦å–å†³äºè¿™ä¸ªç±»å‹ä¸Šæ˜¯ä¸æ˜¯å·²ç»å®šä¹‰äº†å…¶ä»–ä½¿ç”¨äº†æŒ‡é’ˆä½œä¸º receiver çš„æ–¹æ³•ï¼Œå¦‚æœæœ‰ï¼Œåº”è¯¥ä¿æŒä¸€è‡´ï¼Œè¿™ä¸ªç±»å‹ä¸Šæ‰€æœ‰æ–¹æ³•éƒ½ç»Ÿä¸€ä½¿ç”¨æŒ‡é’ˆä½œä¸º receiverã€‚

```go
type Counter struct {
	total      int
	lastUpdate time.Time
}

func (c *Counter) Increment() {
	c.total++
	c.lastUpdate = time.Now()
}

func (c Counter) String() string {
	return fmt.Sprintf("current value %d, last updte: %s", c.total, c.lastUpdate)
}

func main() {
	var c Counter
	fmt.Println(c.String())
	c.Increment()
	fmt.Println(c.String())
}
```

æ³¨æ„è¿™é‡ŒæŒ‡é’ˆç±»å‹çš„ receiverï¼Œåœ¨è°ƒç”¨å…¶æ–¹æ³•æ—¶ï¼Œæœ¬è´¨ä¸Šæ˜¯åšäº†æ¬¡è½¬æ¢ï¼Œç”±æŒ‡é’ˆç±»å‹è½¬æˆå€¼ç±»å‹åå†è°ƒç”¨çš„ï¼Œå³ `c.Increment()` å®é™…ä¸Šä¸º `(&c).Increment()`ã€‚

ä½œä¸ºå‚æ•°ä¼ é€’ç»™å…¶ä»–å‡½æ•°æ—¶ï¼Œæ³¨æ„å€¼ä¼ é€’æ—¶ï¼Œå‡½æ•°ä¿®æ”¹çš„æ˜¯å‰¯æœ¬ã€‚æ‰€ä»¥åœ¨å‡½æ•°ä¸­è°ƒç”¨ receiver æ–¹æ³•æ—¶ï¼Œå¯¹åŸå€¼æ— å½±å“ã€‚

```go
func updateRight(p *Counter) {
	p.Increment()
	fmt.Println("right ", p.String())
}

func updateWrong(c Counter) {
	c.Increment()
	fmt.Println("wrong ", c.String())
}

func main() {
	var c Counter
	updateWrong(c)
	fmt.Println(c.String())
	updateRight(&c)
	fmt.Println(c.String())
}
```

è¾“å‡ºï¼š

```bash
wrong  current value 1, last updte: ...
current value 0, last updte: ...
right  current value 1, last updte: ...
current value 1, last updte: ...
```

## getter & setter

ä¸å»ºè®®ç¼–å†™ getter åŠ setter æ–¹æ³•ï¼ŒGo é¼“åŠ±ç›´æ¥è®¿é—®ç»“æ„ä½“ä¸­å­—æ®µï¼Œè€Œå°†æ–¹æ³•ç•™ç»™ä¸šåŠ¡é€»è¾‘ã€‚ä¸€äº›ä¾‹å¤–çš„æƒ…å†µæ˜¯ä¸€æ¬¡è°ƒç”¨éœ€è¦æ›´æ–°å¤šä¸ªå­—æ®µï¼Œæˆ–è€…æ–¹æ³•ä¸åªæ˜¯ç”¨æ¥å•çº¯æ›´æ–°æŸä¸ªå­—æ®µçš„æ“ä½œã€‚

## å¤„ç† nil

å¦‚æœæ˜¯å€¼ç±»å‹çš„ `nil` å°è¯•ä»å…¶èº«ä¸Šè°ƒç”¨æ–¹æ³•æ—¶ä¼šç›´æ¥ panicï¼Œå¦‚æœæ˜¯æŒ‡é’ˆç±»å‹çš„ receiverï¼Œåˆ™å–å†³äº æ–¹æ³•ä¸­æ˜¯å¦æœ‰é’ˆå¯¹ `nil` çš„å¤„ç†é€»è¾‘ã€‚

ä»¥ä¸‹äºŒå‰æ ‘ç¤ºä¾‹å±•ç¤ºäº† `nil` çš„å¤„ç†ã€‚

```bash
type IntTree struct {
	val         int
	left, right *IntTree
}

func (it *IntTree) Insert(val int) *IntTree {
	if it == nil {
		return &IntTree{val: val}
	}
	if val < it.val {
		it.left = it.left.Insert(val)
	} else if val > it.val {
		it.right = it.right.Insert(val)
	}
	return it
}

func (it *IntTree) Contains(val int) bool {
	switch {
	case it == nil:
		return false
	case val < it.val:
		return it.left.Contains(val)
	case val > it.val:
		return it.right.Contains(val)
	default:
		return true
	}
}

func main() {
	var it *IntTree

	it = it.Insert(1)
	it = it.Insert(2)
	it = it.Insert(3)
	fmt.Println(it.Contains(2)) // true
	fmt.Println(it.Contains(4)) // false
}
```

æ³¨æ„åˆ°ä¸Šåœ¨ `Contains` æ–¹æ³•å¹¶ä¸éœ€è¦ä¿®æ”¹å®ä¾‹ï¼Œä½†è¿˜æ˜¯å£°æ˜çš„æŒ‡é’ˆå…¥å‚ã€‚è¿™é‡Œæ˜¯å‡ºäºè¦åˆ¤æ–­ `nil` çš„è€ƒè™‘ï¼Œæ¯•ç«Ÿå€¼ç±»å‹æ˜¯æ— æ³•åŒºåˆ† `nil` çš„ã€‚

## æ–¹æ³•ä¹Ÿæ˜¯å‡½æ•°

åœ¨æ‰€æœ‰éœ€è¦å‡½æ•°ç±»å‹çš„åœ°æ–¹ï¼Œæ–¹æ³•ä¹Ÿé€‚ç”¨ã€‚å½“å°†æ–¹æ³•ä½œä¸ºå€¼èµ‹å€¼æˆ–ä¼ å‚æ—¶ï¼Œç§°ä¸ºæ–¹æ³•å€¼ï¼ˆmethod valueï¼‰ã€‚

```bash
type Adder struct {
	i int
}

func (a Adder) AddTo(i int) int {
	return a.i + i
}

func main() {
	myAdder := Adder{
		i: 1,
	}
	f := myAdder.AddTo
	f2 := Adder.AddTo
	fmt.Println(f(1), f2(myAdder, 2)) // 2 3
}
```

å¦‚ä¸Šé¢ç¤ºä¾‹æ‰€å±•ç¤ºï¼Œç”šè‡³å¯ä»¥ç›´æ¥ä»ç»“æ„ä½“ç±»å‹åˆ›å»ºæ–¹æ³•ï¼ˆæ­¤æ—¶å« method expressionï¼‰ï¼Œåªä¸åœ¨è°ƒç”¨çš„æ—¶å€™éœ€è¦æŒ‡å®š receiverï¼Œå…¶å®Œæ•´ç­¾åå˜æˆäº† `func(Adder, int) int`ã€‚

## ç±»å‹å®šä¹‰å¹¶ä¸ä¼šç»§æ‰¿

é™¤äº†å¯¹å†…ç½®ç±»å‹å¯è¿›è¡Œ `type` æ“ä½œï¼Œå¯¹äºç”¨æˆ·è‡ªå®šä¹‰çš„ç±»å‹ä¹Ÿæ˜¯ä¸€æ ·çš„ã€‚ä½† Go ä¸­é€šè¿‡ `type` å®šä¹‰çš„æ–°ç±»å‹ï¼Œå’ŒåŸç±»å‹ä¹‹é—´å¹¶ä¸å­˜åœ¨ç»§æ‰¿æ“ä½œï¼ŒåŸç±»å‹ä¸Šå®šä¹‰çš„æ–¹æ³•åœ¨æ–°ç±»å‹ä¸Šä¹Ÿä¸ä¼šæœ‰ã€‚ä¸¤ç§ç±»å‹çš„å€¼ç”šè‡³ä¸é€šç”¨ï¼Œå¿…éœ€ç»è¿‡ç±»å‹è½¬æ¢æ‰èƒ½èµ‹å€¼ã€‚

```go

type Adder struct {
	i int
}

func (a Adder) AddTo(i int) int {
	return a.i + i
}

type AdderAlias Adder

func main() {
	myAdder := Adder{
		i: 1,
	}
	var myAdder2 AdderAlias

	myAdder2 = myAdder // ğŸš¨ cannot use myAdder (variable of type Adder) as AdderAlias value in assignmentcompilerIncompatibleAssign
	
	myAdder2 = AdderAlias(myAdder) // âœ…

	f2 := AdderAlias.AddTo // ğŸš¨ AdderAlias.AddTo undefined (type AdderAlias has no field or method AddTo)compilerMissingFieldOrMethod

	fmt.Println( f2(myAdder2, 2)) // 2 3
}
```

## ä½¿ç”¨ `iota` æ¥å£°æ˜æšä¸¾

Go ä¸­åŸç”Ÿä¸æ”¯æŒæšä¸¾ï¼Œä½†å¯é€šè¿‡ `iota` æ¥å˜ç›¸å®ç°ã€‚

é¦–å…ˆåŸºäº `int` å®šä¹‰ä¸€ä¸ªæšä¸¾ä¸­è¦ä½¿ç”¨çš„ç±»å‹ï¼Œç„¶åä½¿ç”¨ `const` å£°æ˜ä¸€ç»„å˜é‡ä»£è¡¨æšä¸¾å€¼ï¼ŒåŒæ—¶å°†ç¬¬ä¸€ä¸ªèµ‹å€¼ä¸º `iota`:

```go
const (
		Uncategorized MailCategory = iota
		Persional
		Spam
		Social
		Ad
	)
	fmt.Println(Uncategorized, Persional, Spam) // 0 1 2
```

å½“ç¼–è¯‘å™¨é‡åˆ° `iota` æ—¶ï¼Œä¼šå°†åç»­å˜æ›´è®¾ç½®æˆåŒç±»å‹å¹¶é€’å¢èµ‹å€¼ã€‚å³ä½¿ç¬¬ä¸€ä¸ªå€¼ä¸º 0ï¼Œç¬¬äºŒä¸ªä¸º 1... ç›´åˆ°æ–°çš„ `const` è¯­å¥ï¼Œéƒ½ä¼šé‡ç½®æˆ 0ã€‚

## é€šè¿‡ Composit æ¥è¿›è¡Œä»£ç å¤ç”¨

Go ä¸­æ²¡æœ‰ç»§æ‰¿ï¼Œé¼“åŠ±é€šè¿‡ composition åŠ promition æ¥è¿›è¡Œä»£ç å¤ç”¨ã€‚å…·ä½“æ“ä½œå¦‚ä¸‹ï¼š

```go
type Employee struct {
	Name string
	ID   string
}

func (e Employee) Description() string {
	return fmt.Sprintf("%s (%s)", e.Name, e.ID)
}

type Manager struct {
	Employee
	Reports []Employee
}

func main() {
	mgr := Manager{
		Employee: Employee{
			Name: "foo",
			ID:   "xxx",
		},
		Reports: []Employee{},
	}

	fmt.Println(mgr.ID)            // xxx
	fmt.Println(mgr.Description()) // foo (xxx)

}
```

å…¶ä¸­ `Manager` ç»“æ„ä½“ä¸­æœ‰ä¸ª `Employee` ç±»å‹ï¼Œæ²¡æœ‰æŒ‡å®šåå­—ï¼Œæ­¤æ—¶å½¢æˆäº†ä¸€ä¸ªåµŒå…¥å­—æ®µ (embedded field)ï¼ŒåµŒå…¥å­—æ®µèº«ä¸Šçš„å­—æ®µåŠæ–¹æ³•ä¼šå®Œå…¨æš´éœ²(promopted)ç»™å®¿ä¸»ç»“æ„ä½“ï¼Œè¿™æ · `Manager` å°±åŒ…å«äº† `Employee` èº«ä¸Šçš„å­—æ®µåŠæ–¹æ³•äº†ï¼Œæ‰€ä»¥å¯ä»¥é€šè¿‡ `Manager` å®ä¾‹è®¿é—® `ID`ï¼Œ`Name` å­—æ®µä»¥åŠè°ƒç”¨ `Description` æ–¹æ³•ã€‚

å¦‚æœå®¿ä¸»åˆšå¥½æœ‰åŒåå­—æ®µæˆ–æ–¹æ³•ï¼Œå¯¹åº”åµŒå…¥å­—æ®µçš„åŒåå¯¹è±¡ä¼šè¢«è¦†ç›–ï¼Œåªèƒ½é€šè¿‡æ˜¾å¼æŒ‡å®šåµŒå…¥å¯¹è±¡çš„ç±»å‹æ¥è®¿é—®ï¼Œè­¬å¦‚ï¼š

```diff
	type Manager struct {
		Employee
		Reports []Employee
+		ID      string
	}

	func main() {
		mgr := Manager{
			Employee: Employee{
				Name: "foo",
				ID:   "xxx",
			},
			Reports: []Employee{},
+			ID:      "yyy",
		}
	
		fmt.Println(mgr.ID)            // yyy
+		fmt.Println(mgr.Employee.ID)   // xxx
		fmt.Println(mgr.Description()) // foo (xxx)
	
	}
```

## æ¥å£/Interface

ä¸‹é¢æ˜¯æ¥è‡ª `fmt` åŒ…é‡Œçš„ `Stringer` æ¥å£ï¼Œé€šè¿‡å…¶å£°æ˜çš„å½¢å¼æ¥çœ‹æ¥å£çš„å®šä¹‰ï¼š

```go
type Stringer interface {
	Strign() string
}
```

æ¥å£åä¸€èˆ¬ä»¥ `er` ç»“å°¾ï¼Œé™¤äº†ä¸Šé¢çš„ `Stringer` è¿˜æ¯”å¦‚ `io.Reader` ï¼Œ`io.Closer`ï¼Œ`json.Mashler` ...

å’Œå…¶ä»–è¯­è¨€ä¸­æ¥å£ä¸åŒï¼ŒGo ä¸­ç±»å‹æ— éœ€æ˜¾å¼å£°æ˜å®ç°äº†æŸæ¥å£ï¼Œæ¥å£æ˜¯éšå¼å®ç°çš„ã€‚å³ï¼Œå¦‚æœç±»å‹çš„æ–¹æ³•åˆ—è¡¨ä¸­åŒ…å«äº†æŸæ¥å£çš„æ‰€æœ‰æ–¹æ³•ï¼Œæ‰€è¯¥ç±»å‹å®ç°äº†è¯¥æ¥å£ã€‚æ­¤æ—¶è¯¥ç±»å‹å°±èƒ½èµ‹å€¼ç»™è¿™ç§æ¥å£ç±»å‹çš„å˜é‡ã€‚

```go
type Logic interface {
	Process(data string) string
}

type LogicProvider struct{}

func (lp LogicProvider) Process(data string) string {
	//
}

type Client struct {
	L Logic
}

func main() {
	c := Client{
		L: LogicProvider{},
	}
	fmt.Println(c.L.Process("xxx"))
}
```

æ¥å£æŒ‡æ˜äº†è°ƒç”¨æ–¹æ³•éœ€è¦ä»€ä¹ˆï¼Œä¸Šé¢ `client` ä¸­ä½¿ç”¨äº† `Logic` æ¥å£ï¼Œè€Œ `LogicProvider` å¯¹æ¥å£æ˜¯æ— æ„ŸçŸ¥çš„ã€‚ 

## æ¥å£çš„å†…åµŒ

ä¸ç»“æ„ä½“ä¸€æ ·ï¼Œæ¥å£ä¹Ÿå¯å†…åµŒåˆ°å¦ä¸€ä¸ªæ¥å£ï¼š

```go
type Reader interface {
	Read(p []byte) (n int, err error)
}

type Closer interface {
	Close() error
}

type ReadCloser interface {
	Reader
	Closer
}
```

## æ¥å£å…¥ï¼Œç±»å‹å‡º

å‡½æ•°åº”è¯¥æ»¡è¶³ "Accept interface, return structs", ä½¿ç”¨æ¥å£ä½œä¸ºå‡½æ•°å…¥å‚çš„çº¦æŸï¼Œä¸€æ˜¯æ›´åŠ çµæ´»ï¼ŒäºŒæ˜¯æ›´åŠ èƒ½è¡¨æ˜å‡½æ•°çš„æ„å›¾ã€‚

è¿”å›æ¥å£ä½¿å¾—åç»­å˜æ›´æ›´å›°éš¾ï¼Œæ¯”å¦‚æ¥å£ä¸­å¢åŠ å­—æ®µï¼Œæ‰€æœ‰åœ°æ–¹éƒ½éœ€è¦æ›´æ–°ï¼Œè€Œå¦‚æœè¿”å›ç»“æ„ä½“ï¼Œåˆ™æ²¡æœ‰è¿™ä¸ªé—®é¢˜ã€‚

## æ¥å£ä¸ `nil`

æ¥å£çš„åº•å±‚å®ç°æ˜¯ä¸€å¯¹æŒ‡é’ˆï¼Œä¸€ä¸ªæŒ‡å‘ç±»å‹ä¸€ä¸ªæŒ‡å‘å€¼ï¼Œ ä½¿å¾—æ¥å£ä¸º `nil` éœ€è¦ç±»å‹å’Œå€¼å‡ä¸º `nil`ã€‚åªè¦ç±»å‹ä¸ `nil` åˆ™æ¥å£å°±ä¸ `nil` äº†ï¼ˆä¸€ä¸ªå˜é‡ä¸å¯èƒ½æ²¡æœ‰ç±»å‹ï¼Œæ‰€ä»¥å¦‚æœå€¼ä¸ç©ºï¼Œé‚£ç±»å‹å¿…ç„¶ä¸ç©ºï¼‰ã€‚è¯·çœ‹ä»¥ä¸‹ç¤ºä¾‹ï¼š

```go
func main() {
	var s *string
	fmt.Println(s == nil) // true

	var i interface{}
	fmt.Println(i == nil) // true

	i = s
	fmt.Println(i == nil) // false
}
```

æ¥å£ä¸ºç©ºè¡¨ç¤ºæ— æ³•è°ƒç”¨å…¶æ–¹æ³•ã€‚ä½†æ¥å£ä¸ä¸ºç©ºä¹Ÿå¹¶ä¸ä»£è¡¨å°±èƒ½è°ƒæˆåŠŸï¼Œå› ä¸º Go ä¸­ç©ºå®ä¾‹ä¹Ÿæ˜¯å¯ä»¥æ­£å¸¸è°ƒç”¨çš„ï¼Œå‰ææ˜¯å®ä¾‹çš„æ–¹æ³•æ­£ç¡®å¤„ç†äº† `nil` çš„æƒ…å†µï¼Œå¦åˆ™ä¼š panicã€‚

æ—¢ç„¶æ¥å£çš„å€¼å¯èƒ½ä¸ºç©ºï¼Œä½†æ­¤æ—¶æ¥å£åˆä¸ç©ºï¼Œå°±éœ€è¦ç”¨åˆ°åå°„æ¥åˆ¤æ–­æ¥å£çš„å€¼æ˜¯å¦ä¸ºç©ºã€‚æ­¤å¤„å…ˆä¸æ¶‰åŠã€‚

## ç©ºæ¥å£

é™æ€å¼ºç±»å‹è¯­è¨€ä¸­å°‘ä¸äº†éœ€è¦è¿™ä¹ˆç§å˜é‡ï¼Œå®ƒå¯ä»¥å­˜æ”¾ä»»æ„ç±»å‹çš„å€¼ï¼ŒGo ä¸­ç©ºæ¥å£ä¾¿å¯ä»¥æ»¡è¶³ã€‚

```go
var i interface{}

	i = 1
	i = "foo"
	i = struct {
		Name string
		Age  int
	}{
		Name: "bar",
		Age:  22,
	}
```

ç©ºæ¥å£è¡¨ç¤ºå˜é‡å¯æ¥å—æ‰€æœ‰å®ç°äº†é›¶çš„ç±»å‹ï¼Œè€Œ Go ä¸­æ‰€æœ‰ç±»å‹éƒ½æœ‰é›¶å€¼ï¼Œæ‰€ä»¥å¯å°†ä»»æ„ç±»å‹èµ‹å€¼ç»™ç©ºæ¥å£ã€‚ç©ºæ¥å£ä¼šç”¨åœ¨ä¸€äº›ç‰¹æ®Šçš„åœºæ™¯ï¼Œæ¯”å¦‚æ¥æ”¶æ¥è‡ª JSON ä¸­çš„å¤–æ¥æ•°æ®æ—¶ã€‚

```go
func main() {
	data := map[string]interface{}{}
	contens, err := ioutil.ReadFile("./data.json")
	json.Unmarshal(contens, &data)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
	fmt.Println(data)
}
```

å› ä¸º Go ä¸æ”¯æŒæ³›å‹ï¼Œå½“ç”¨æˆ·è‡ªå®šä¹‰çš„ç±»å‹æƒ³æ”¯æŒå¤šç§ç±»å‹æ—¶ï¼Œå°±å¯ä»¥ç”¨ç©ºæ¥å£æ¥å®ç°ã€‚

```go
type LinkedList struct {
	Value interface{}
	Next  *LinkedList
}

func (ll *LinkedList) Insert(pos int, val interface{}) *LinkedList {
	if ll == nil || pos == 0 {
		return &LinkedList{
			Value: val,
			Next:  ll,
		}
	}
	ll.Next = ll.Next.Insert(pos-1, val)
	return ll
}
```

ä½†å®æˆ˜ä¸­å°½é‡é¿å…ä½¿ç”¨ `interface{}` ï¼Œå› ä¸ºè¿™æ ·ä¼šä¸¢å¤± Go å¼ºç±»å‹çš„ä¼˜åŠ¿ã€‚

## ç±»å‹æ–­è¨€åŠç±»å‹åˆ‡æ¢

ä» `interface{}` ä¸­å†æŠŠå€¼è¿˜åŸå›æ¥æœ‰ä¸¤ç§æ–¹å¼ï¼Œç±»å‹æ–­è¨€ï¼ˆtype assertionï¼‰å’Œç±»å‹åˆ‡æ¢ï¼ˆtype switchï¼‰ã€‚

å…ˆçœ‹ç±»å‹æ–­è¨€ï¼š

```go
type MyInt int

func main() {
	var i interface{}
	var num MyInt=20
	i=num
	num2 :=i.(MyInt) // 20
	num3:=i.(string) // ğŸš¨ panic: interface conversion: interface {} is main.MyInt, not string
	fmt.Println(num2,num3)
}
```

å¦‚ä¸Šæ‰€ç¤ºï¼Œå¦‚æœåœ¨è¿›è¡Œç±»å‹æ–­è¨€æ—¶ï¼ŒæŒ‡å®šäº†é”™è¯¯çš„ç±»å‹ä¼šç›´æ¥ panicï¼Œè‰¯å¥½çš„ä»£ç éœ€è¦è¿›è¡Œé”™è¯¯å¤„ç†ï¼Œagainï¼Œcomma ok å½¢å¼åº”ç”¨èµ·æ¥ï¼š

```go
num3,ok:=i.(string)
if ok{
	fmt.Println(num3)
}
```

å»ºè®®å§‹ç»ˆè¿›è¡Œé”™è¯¯å¤„ç†ï¼Œè¿™æ ·èƒ½ä¿è¯ä»£ç çš„å¥å£®æ€§ï¼Œé˜²æ­¢åæœŸä¸ç»æ„çš„ä¿®æ”¹å¯¼è‡´çš„é”™è¯¯ã€‚

### ç±»å‹æ–­è¨€ä¸ç±»å‹è½¬æ¢çš„åŒºåˆ†

ç±»å‹æ–­è¨€ä¸ç±»å‹å¼ºè½¬ï¼ˆtype castï¼‰è¿˜ä¸ä¸€æ ·ï¼Œ

- å‰è€…åªèƒ½åº”ç”¨äºæ¥å£ï¼Œè¿è¡Œæ—¶è¿›è¡Œ
- åè€…å¯ç”¨äºæ¥å£æˆ–å…·ä½“ç±»å‹ï¼Œç¼–è¯‘æ—¶è¿›è¡Œ

å½“æ¥å£å¯å¯¹åº”å¤šç§ç±»å‹æ—¶ï¼Œåˆ™ä½¿ç”¨ç±»å‹åˆ‡æ¢ï¼ˆtype switchï¼‰æ¥è½¬æ¢ã€‚

```go
type MyInt int

func doThings(i interface{}) {
	switch i := i.(type) {
	case nil:
		fmt.Println("type of nil")
	case MyInt, int:
		fmt.Println("type of int")
	case io.Reader:
		fmt.Println("type of io.Reader")
	case string:
		fmt.Println("type of string")
	default:
		fmt.Println("unknown type, stay as interface{}", i)
	}
}

func main() {
	num := 1
	var i interface{}
	i = num
	doThings(i)
}
```

æ³¨æ„ï¼šç±»å‹åˆ‡æ¢åªæ˜¯ç”¨åœ¨ä½ æ˜ç¡®çŸ¥é“å®ƒå¯èƒ½çš„ç±»å‹ï¼Œå¦‚æœä¸çŸ¥é“ï¼Œæ­£ç¡®çš„åšæ³•æ˜¯ä½¿ç”¨åå°„ã€‚

## éšå¼æ¥å£åˆ©äºä¾èµ–æ³¨å…¥

Go çš„è¿™ç§éšå¼æ¥å£å®ç°ï¼Œå¯¹ä¾èµ–æ³¨å…¥å¾ˆå‹å¥½ã€‚ä¸‹é¢é€šè¿‡æ„å»ºä¸€ä¸ª web åº”ç”¨æ¥è¯´æ˜ã€‚

å…ˆç¼–å†™ä¸€ä¸ªæ‰“å°æ—¥å¿—çš„å‡½æ•°ï¼š

```go
func LogOutput(message string) {
	fmt.Println(message)
}
```

åŒæ—¶åˆ›å»ºä¸€ä¸ªæ•°æ®æºï¼Œä»é‡Œé¢è·å–ç”¨æˆ·æ•°æ®ï¼Œå¹¶ä¸”åˆ›å»ºä¸€ä¸ªå·¥å…·æ–¹æ³•æ¥è·å–ä¸€äº›å‡æ•°æ®ï¼š

```go
type SimpleDataStore struct {
	userData map[string]string
}

func (sds SimpleDataStore) GetUserNameById(userId string) (string, bool) {
	name, ok := sds.userData[userId]
	return name, ok
}

func NewSimpleDataStore() SimpleDataStore {
	return SimpleDataStore{
		userData: map[string]string{
			"1": "foo",
			"2": "bar",
			"3": "baz",
		},
	}
}
```

ä¸šåŠ¡é€»è¾‘æ˜¯è¿™æ ·çš„ï¼Œä»æ•°æ®æºæ ¹æ® ID æŸ¥è¯¢ç”¨æˆ·ï¼Œ say hello and goodbyeã€‚ä¸šåŠ¡è°ƒç”¨çš„æ—¶å€™ï¼ŒåŒæ—¶æ‰“å°äº›æ—¥å¿—ã€‚æ‰€ä»¥è¿™é‡Œèƒ½å¤Ÿç”¨ä¸Šå‰é¢åˆ›å»ºçš„æ•°æ®æºå’Œæ—¥å¿—å‡½æ•°ã€‚ä½†æˆ‘ä»¬å¹¶ä¸æƒ³æ˜¾å¼ä¾èµ– `SimpleDataStore` å’Œ `LogOutput`ï¼Œè€ƒè™‘åˆ°çœŸå®éœ€æ±‚åœºæ™¯ä¸‹ï¼Œåç»­å¯èƒ½ä¼šæ¢ä¸€ç§æ•°æ®æºåŠæ—¥å¿—è¾“å‡ºæœåŠ¡ã€‚

å› æ­¤ï¼Œè¿™é‡Œåªéœ€è¦å®šä¹‰å¥½æ¥å£æ¥è¡¨æ˜ä¸šåŠ¡ä¸­éœ€è¦ä»€ä¹ˆï¼Œä¸€ä¸ªæ•°æ®æºï¼Œä¸€ä¸ªæ—¥å¿—æ‰“å°æœåŠ¡ï¼š

```go
type DataStore interface {
	GetUserNameById(userId string) (string, bool)
}

type Logger interface {
	Log(message string)
}
```

æ³¨æ„åˆ°å‰é¢å®šä¹‰çš„æ—¥å¿—æ‰“å°å‡½æ•°ï¼Œå¹¶ä¸ç›´æ¥æ»¡è¶³è¿™é‡Œçš„æ¥å£å®šä¹‰ï¼Œæ‰€ä»¥å®šä¹‰ä¸€ä¸ªå‡½æ•°ç±»å‹ï¼Œåœ¨è¿™ä¸ªç±»å‹ä¸Šå†å®šä¹‰ä¸€ä¸ªæ»¡è¶³æ¥å£çš„æ–¹æ³•ï¼š

```go
type LoggerAdapter func(message string)

func (la LoggerAdapter) Log(message string) {
	la(message)
}
```

åˆ°æ­¤ï¼Œ`LoggerAdapter` å’Œ `SimpleDataStore` åˆšå¥½å°±æ»¡è¶³æ¥å£çš„éœ€è¦äº†ã€‚ä½†å¦‚æœä»è¿™ä¸¤ç±»å‹è‡ªèº«çš„åº¦è§’æ¥çœ‹ï¼Œä»–ä»¬æ˜¯å®Œå…¨ä¸çŸ¥æƒ…çš„ï¼Œå› ä¸ºå…¶èº«ä¸Šå¹¶æ²¡æœ‰åƒå…¶ä»–è¯­è¨€ä¸€æ ·ï¼Œé€šè¿‡ä¸€äº›ä»€ä¹ˆæ ‡è¯†è¯­æ³•ä¹‹ç±»çš„ï¼Œæ¥å£°æ˜æ”¯æŒäº†æŸä¸ªæ¥å£ã€‚è¿™ä¾¿æ˜¯è§£è€¦ã€‚

å¤–éƒ¨ä¾èµ–å‡†å¤‡å°±ç»ªï¼Œä¸‹é¢çœ‹ä¸šåŠ¡é€»è¾‘ã€‚

```go
type SimpleLogic struct {
	l  Logger
	ds DataStore
}

func (sl SimpleLogic) SayHello(userId string) (string, error) {
	sl.l.Log("in SayHello for user:" + userId)
	name, ok := sl.ds.GetUserNameById(userId)
	if !ok {
		return "", errors.New("unkown user")
	}
	return "hello ," + name, nil
}

func (sl SimpleLogic) SayGoodbye(userId string) (string, error) {
	sl.l.Log("in SayGoodbye for user:" + userId)
	name, ok := sl.ds.GetUserNameById(userId)
	if !ok {
		return "", errors.New("unkown user")
	}
	return "goodbye," + name, nil
}
```

åŒæ ·ï¼Œä¸šåŠ¡é€»è¾‘é‡Œä¹Ÿæ²¡æœ‰è§„å®šä¾èµ–çš„å…·ä½“ç±»å‹ï¼Œåªæ˜¯ä¸¤ä¸ªæ¥å£ã€‚å½“æˆ‘ä»¬éœ€è¦å®ä¾‹çš„æ—¶å€™ï¼Œåªéœ€è¦ä¼ å…¥æ»¡è¶³æ¥å£çš„å‚æ•°å³å¯ï¼Œå¹¶æ²¡æœ‰å¼ºåˆ¶å¿…éœ€æ˜¯æŸä¸ªç±»å‹ï¼š

```go
func NewSimpleLogic(l Logger, ds DataStore) SimpleLogic {
	return SimpleLogic{
		l:  l,
		ds: ds,
	}
}
```

æœ€å Controlle ä¸­çš„é€»è¾‘ï¼Œå…¶ä¸­åŒ…å«ä¸Šé¢å®šä¹‰çš„ä¸šåŠ¡é€»è¾‘ï¼Œä½†è¿™é‡Œä¹Ÿä¸å›ºå®šå’Œ `SimpleLogic` è¿™ä¸€ç±»å‹å…·ä½“ç»‘å®šï¼Œè¿˜æ˜¯é€šè¿‡å®šä¹‰ä¸€ä¸ªæ¥å£æ¥è¡¨æ˜æˆ‘ä»¬éœ€è¦ä»€ä¹ˆï¼š

```go
type Logic interface {
	SayHello(userId string) (string, error)
}

type Controller struct {
	l     Logger
	logic Logic
}
```

ç„¶åæ˜¯ Controller ä¸­çš„å…·ä½“é€»è¾‘ï¼ŒåŒæ ·åœ°ï¼Œä¹Ÿåˆ›å»ºä¸€ä¸ªå·¥å…·æ–¹æ³•æ¥ç”Ÿæˆæ–°çš„å®ä¾‹ï¼š

```go
func (c Controller) HandleGreeting(w http.ResponseWriter, r *http.Request) {
	c.l.Log("in controller HandleGreeting")
	userId := r.URL.Query().Get("user_id")
	message, err := c.logic.SayHello(userId)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		w.Write([]byte(err.Error()))
		return
	}
	w.Write([]byte(message))
}

func NewController(l Logger, logic Logic) Controller {
	return Controller{
		l:     l,
		logic: logic,
	}
}
```

å¯ä»¥çœ‹åˆ°è¿™é‡Œå·¥å…·æ–¹æ³•è·µè¡Œäº†å‰é¢æåˆ°çš„æœ€ä½³å®è·µï¼šæ¥å£å…¥ç±»å‹å‡ºã€‚å…¥å‚ä¸ºæ¥å£ï¼Œè¿”å›å…·ä½“ç±»å‹ã€‚

main å‡½æ•°çš„é€»è¾‘ï¼š

```bash
func main() {
	l := LoggerAdapter(LogOutput)
	ds := NewSimpleDataStore()
	logic := NewSimpleLogic(l, ds)
	c := NewController(l, logic)
	http.HandleFunc("/hello", c.HandleGreeting)
	http.ListenAndServe(":8080", nil)
}
```

è¿™é‡Œä¸»å‡½æ•°ä¸­ï¼Œæ˜¯å…¨ç¨‹åºé‡Œå”¯ä¸€çŸ¥é“æ‰€æœ‰å…·ä½“ç±»å‹çš„åœ°æ–¹ï¼Œå¦‚æœåæœŸæ¢å®ç°ï¼Œåªéœ€è¦æ”¹ä¸»å‡½æ•°å³å¯ã€‚

æµ‹è¯•ï¼š

```bash
$ curl "localhost:8080/hello?user_id=1"
hello ,fooâ
$ curl "localhost:8080/hello?user_id=4"
unkown userâ
```

ä»¥ä¸Šã€‚
