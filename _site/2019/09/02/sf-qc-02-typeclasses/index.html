<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta name="description" content="notes about the coding life">
    <meta name="keywords"  content="牛哇勇, 博客, 互联网, Web, JavaScript, 前端, 设计">
    <meta name="theme-color" content="#000000">
    
    <!-- Open Graph -->
    <meta property="og:title" content="「SF-QC」2 TypeClasses - 牛さんの部落格|刘哇勇的部落格">
    
    <meta property="og:type" content="article">
    <meta property="og:description" content="Considerring printing different types with this common idiom:
">
    
    <meta property="article:published_time" content="2019-09-02T00:00:00Z">
    
    
    <meta property="article:author" content="Hux">
    
    
    <meta property="article:tag" content="SF (软件基础)">
    
    <meta property="article:tag" content="QC (Quickcheck)">
    
    <meta property="article:tag" content="Coq">
    
    <meta property="article:tag" content="笔记">
    
    
    <meta property="og:image" content="http://0.0.0.0:4000">
    <meta property="og:url" content="http://0.0.0.0:4000/2019/09/02/sf-qc-02-typeclasses/">
    <meta property="og:site_name" content="牛さんの部落格|刘哇勇的部落格">
    
    <title>「SF-QC」2 TypeClasses - 牛さんの部落格|刘哇勇的部落格</title>

    <!-- Web App Manifest -->
    <link rel="manifest" href="/pwa/manifest.json">

    <!-- Favicon -->
    <link rel="shortcut icon" href="/img/favicon.ico">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="http://0.0.0.0:4000/2019/09/02/sf-qc-02-typeclasses/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


  <!-- hack iOS CSS :active style -->
  <body ontouchstart="">
    <!-- Navigation -->

<nav class="navbar navbar-default navbar-custom navbar-fixed-top invert">
    
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">牛さんの部落格</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div id="huxblog_navbar">
                <div class="navbar-collapse">
                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="/">Home</a>
                        </li>
                        
                        
                        
                        
                        <li>
                            <a href="/about/">关于</a>
                        </li>
                        
                        
                        
                        <li>
                            <a href="/archive/">Archive</a>
                        </li>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <li class="search-icon">
                            <a href="javascript:void(0)">
                                <i class="fa fa-search"></i>
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <script>
        // Drop Bootstarp low-performance Navbar
        // Use customize navbar with high-quality material design animation
        // in high-perf jank-free CSS3 implementation
        var $body = document.body;
        var $toggle = document.querySelector('.navbar-toggle');
        var $navbar = document.querySelector('#huxblog_navbar');
        var $collapse = document.querySelector('.navbar-collapse');

        var __HuxNav__ = {
            close: function () {
                $navbar.className = " ";
                // wait until animation end.
                setTimeout(function () {
                    // prevent frequently toggle
                    if ($navbar.className.indexOf('in') < 0) {
                        $collapse.style.height = "0px"
                    }
                }, 400)
            },
            open: function () {
                $collapse.style.height = "auto"
                $navbar.className += " in";
            }
        }

        // Bind Event
        $toggle.addEventListener('click', function (e) {
            if ($navbar.className.indexOf('in') > 0) {
                __HuxNav__.close()
            } else {
                __HuxNav__.open()
            }
        })

        /**
         * Since Fastclick is used to delegate 'touchstart' globally
         * to hack 300ms delay in iOS by performing a fake 'click',
         * Using 'e.stopPropagation' to stop 'touchstart' event from 
         * $toggle/$collapse will break global delegation.
         * 
         * Instead, we use a 'e.target' filter to prevent handler
         * added to document close HuxNav.  
         *
         * Also, we use 'click' instead of 'touchstart' as compromise
         */
        document.addEventListener('click', function (e) {
            if (e.target == $toggle) return;
            if (e.target.className == 'icon-bar') return;
            __HuxNav__.close();
        })
    </script> <!-- Search -->
<div class="search-page">
  <div class="search-icon-close-container">
    <span class="search-icon-close">
      <i class="fa fa-chevron-down"></i>
    </span>
  </div>
  <div class="search-main container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <form></form>
        <input type="text" id="search-input" placeholder="$ grep...">
        </form>
        <div id="search-results" class="mini-post-list"></div>
      </div>
    </div>
  </div>
</div> <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/home-bg.jpg" width="0" height="0"> -->

<!-- Post Header -->



<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/img/home-bg.jpg');
        background: ;
    }

    
</style>

<header class="intro-header style-text" >

    <div class="header-mask"></div>
    
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/archive/?tag=SF+%28%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80%29" title="SF (软件基础)">SF (软件基础)</a>
                        
                        <a class="tag" href="/archive/?tag=QC+%28Quickcheck%29" title="QC (Quickcheck)">QC (Quickcheck)</a>
                        
                        <a class="tag" href="/archive/?tag=Coq" title="Coq">Coq</a>
                        
                        <a class="tag" href="/archive/?tag=%E7%AC%94%E8%AE%B0" title="笔记">笔记</a>
                        
                    </div>
                    <h1>「SF-QC」2 TypeClasses</h1>
                    
                    <h2 class="subheading">Quickcheck - A Tutorial on Typeclasses in Coq</h2>
                    <span class="meta">Posted by Hux on September 2, 2019</span>
                </div>
            </div>
        </div>
    </div>
</header>






<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <!-- Multi-Lingual -->
                

				<p>Considerring printing different types with this common idiom:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">showBool</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">bool</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">string</span><span class="w">
</span><span class="no">showNat</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">string</span><span class="w">
</span><span class="no">showList</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">string</span><span class="o">)</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="o">(</span><span class="no">list</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">string</span><span class="w">
</span><span class="no">showPair</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">string</span><span class="o">)</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="o">(</span><span class="no">B</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">string</span><span class="o">)</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">string</span><span class="w">

</span><span class="k">Definition</span><span class="w"> </span><span class="no">showListOfPairsOfNats</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">showList</span><span class="w"> </span><span class="o">(</span><span class="no">showPair</span><span class="w"> </span><span class="no">showNat</span><span class="w"> </span><span class="no">showNat</span><span class="o">)</span><span class="w">   </span><span class="c">(* LOL *)</span><span class="w">
</span></code></pre></div></div>

<blockquote>
  <p>The designers of Haskell addressed this clunkiness through <em>typeclasses</em>, a mechanism by which the typechecker is instructed to automatically construct “type-driven” functions [Wadler and Blott 1989].</p>
</blockquote>

<p>Coq followed Haskell’s lead as well, but</p>

<blockquote>
  <p>because Coq’s type system is so much richer than that of Haskell, and because typeclasses in Coq are used to automatically construct not only programs but also proofs, Coq’s presentation of typeclasses is quite a bit less “transparent”</p>
</blockquote>

<h2 id="basics">Basics</h2>

<h3 id="classes-and-instances">Classes and Instances</h3>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Class</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w">
  </span><span class="no">show</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">string</span><span class="w">
</span><span class="o">}.</span><span class="w">

</span><span class="k">Instance</span><span class="w"> </span><span class="no">showBool</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">bool</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w">
  </span><span class="no">show</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="kr">fun</span><span class="w"> </span><span class="no">b</span><span class="p">:</span><span class="no">bool</span><span class="w"> </span><span class="p">⇒</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="s2">"true"</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="s2">"false"</span><span class="w">
</span><span class="o">}.</span><span class="w">
</span></code></pre></div></div>

<p>Comparing with Haskell:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Show</span> <span class="n">a</span> <span class="kr">where</span>
  <span class="n">show</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">string</span>

<span class="c1">--  you cannot override a `instance` so in reality you need a `newtype` wrapper to do this</span>
<span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">Bool</span> <span class="kr">where</span>
  <span class="n">show</span> <span class="n">b</span> <span class="o">=</span> <span class="kr">if</span> <span class="n">b</span> <span class="kr">then</span> <span class="s">"True"</span> <span class="kr">else</span> <span class="s">"Fasle"</span>
</code></pre></div></div>

<blockquote>
  <p>The show function is sometimes said to be overloaded, since it can be applied to arguments of many types, with potentially radically different behavior depending on the type of its argument.</p>
</blockquote>

<p>Next, we can define functions that use the overloaded function show like this:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">showOne</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">a</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">string</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="s2">"The value is "</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="no">a</span><span class="pi">.</span><span class="w">
  
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">showOne</span><span class="w"> </span><span class="no">true</span><span class="o">).</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">showOne</span><span class="w"> </span><span class="mi">42</span><span class="o">).</span><span class="w">

</span><span class="k">Definition</span><span class="w"> </span><span class="no">showTwo</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w">
           </span><span class="err">`</span><span class="o">{</span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="o">}</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">Show</span><span class="w"> </span><span class="no">B</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">a</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">b</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">B</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">string</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="s2">"First is "</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s2">" and second is "</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="no">b</span><span class="pi">.</span><span class="w">

</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">showTwo</span><span class="w"> </span><span class="no">true</span><span class="w"> </span><span class="mi">42</span><span class="o">).</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">showTwo</span><span class="w"> </span><span class="no">Red</span><span class="w"> </span><span class="no">Green</span><span class="o">).</span><span class="w">
</span></code></pre></div></div>

<blockquote>
  <p>The parameter <code class="language-plaintext highlighter-rouge">`{Show A}</code> is a <em>class constraint</em>, which states that the function showOne is expected to be applied only to types A that belong to the Show class.</p>
</blockquote>

<blockquote>
  <p>Concretely, this constraint should be thought of as an <em>extra parameter</em> to showOne supplying <em>evidence</em> that A is an instance of Show — i.e., it is essentially just a show function for A, which is implicitly invoked by the expression show a.</p>
</blockquote>

<p>读时猜测（后来发现接下来有更正确的解释）：<code class="language-plaintext highlighter-rouge">show</code> 在 name resolution 到 <code class="language-plaintext highlighter-rouge">class Show</code> 时就可以根据其参数的 type（比如 <code class="language-plaintext highlighter-rouge">T</code>）infer 出「我们需要一个 <code class="language-plaintext highlighter-rouge">Show T</code> 的实现（<code class="language-plaintext highlighter-rouge">instance</code>，其实就是个 table）」，在 Haskell/Rust 中这个 table 会在 lower 到 IR 时才 made explicit，而 Coq 这里的语法就已经强调了这里需要 implicitly-and-inferred <code class="language-plaintext highlighter-rouge">{}</code> 一个 table，这个 table 的名字其实不重要，只要其 type 是被 <code class="language-plaintext highlighter-rouge">A</code> parametrized 的 <code class="language-plaintext highlighter-rouge">Show</code> 就好了，类似 ML 的 <code class="language-plaintext highlighter-rouge">functor</code> 或者 Java 的 generic <code class="language-plaintext highlighter-rouge">interface</code>。</p>

<p>This is <em>Ad-hoc polymorphism</em>.</p>

<h4 id="missing-constraint">Missing Constraint</h4>

<p>What if we forget the class constrints:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Error</span><span class="p">:</span><span class="w">
</span><span class="no">Unable</span><span class="w"> </span><span class="no">to</span><span class="w"> </span><span class="no">satisfy</span><span class="w"> </span><span class="no">the</span><span class="w"> </span><span class="no">following</span><span class="w"> </span><span class="no">constraints</span><span class="p">:</span><span class="w">
</span><span class="no">In</span><span class="w"> </span><span class="no">environment</span><span class="p">:</span><span class="w">
</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w">
</span><span class="no">a</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="w">

</span><span class="nv">?Show</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s2">"Show A"</span><span class="w">
</span></code></pre></div></div>

<h4 id="class-eq">Class <code class="language-plaintext highlighter-rouge">Eq</code></h4>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Class</span><span class="w"> </span><span class="no">Eq</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">{</span><span class="w">
    </span><span class="no">eqb</span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">bool</span><span class="p">;</span><span class="w">
  </span><span class="o">}.</span><span class="w">

</span><span class="k">Notation</span><span class="w"> </span><span class="s2">"x =? y"</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="no">eqb</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="kp">at</span><span class="w"> </span><span class="no">level</span><span class="w"> </span><span class="mi">70</span><span class="o">).</span><span class="w">

</span><span class="k">Instance</span><span class="w"> </span><span class="no">eqBool</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Eq</span><span class="w"> </span><span class="no">bool</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">{</span><span class="w">
    </span><span class="no">eqb</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="kr">fun</span><span class="w"> </span><span class="o">(</span><span class="no">b</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">bool</span><span class="o">)</span><span class="w"> </span><span class="p">⇒</span><span class="w"> 
       </span><span class="kr">match</span><span class="w"> </span><span class="no">b</span><span class="o">,</span><span class="w"> </span><span class="no">c</span><span class="w"> </span><span class="kp">with</span><span class="w">
         </span><span class="o">|</span><span class="w"> </span><span class="no">true</span><span class="o">,</span><span class="w"> </span><span class="no">true</span><span class="w"> </span><span class="p">⇒</span><span class="w"> </span><span class="no">true</span><span class="w">
         </span><span class="o">|</span><span class="w"> </span><span class="no">true</span><span class="o">,</span><span class="w"> </span><span class="no">false</span><span class="w"> </span><span class="p">⇒</span><span class="w"> </span><span class="no">false</span><span class="w">
         </span><span class="o">|</span><span class="w"> </span><span class="no">false</span><span class="o">,</span><span class="w"> </span><span class="no">true</span><span class="w"> </span><span class="p">⇒</span><span class="w"> </span><span class="no">false</span><span class="w">
         </span><span class="o">|</span><span class="w"> </span><span class="no">false</span><span class="o">,</span><span class="w"> </span><span class="no">false</span><span class="w"> </span><span class="p">⇒</span><span class="w"> </span><span class="no">true</span><span class="w">
       </span><span class="kr">end</span><span class="w">
  </span><span class="o">}.</span><span class="w">

</span><span class="k">Instance</span><span class="w"> </span><span class="no">eqNat</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Eq</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">{</span><span class="w">
    </span><span class="no">eqb</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="nn">Nat</span><span class="p">.</span><span class="no">eqb</span><span class="w">
  </span><span class="o">}.</span><span class="w">
</span></code></pre></div></div>

<blockquote>
  <p>Why should we need to define a typeclass for boolean equality when <em>Coq’s propositional equality</em> (<code class="language-plaintext highlighter-rouge">x = y</code>) is completely generic? 
while it makes sense to <em>claim</em> that two values <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> are equal no matter what their type is, it is not possible to write a <em>decidable equality checker</em> for arbitrary types. In particular, equality at types like <code class="language-plaintext highlighter-rouge">nat → nat</code> is undecidable.</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">x = y</code> 返回一个需要去证的 <code class="language-plaintext highlighter-rouge">Prop</code> (relational) 而非 executable <code class="language-plaintext highlighter-rouge">Fixpoint</code> (functional)<br />
因为 function 的 equality 有时候会 undeciable，所以才需要加 Functional Extensionality <code class="language-plaintext highlighter-rouge">Axiom</code>（见 LF-06）</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Instance</span><span class="w"> </span><span class="no">eqBoolArrowBool</span><span class="p">:</span><span class="w"> </span><span class="no">Eq</span><span class="w"> </span><span class="o">(</span><span class="no">bool</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">bool</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">{</span><span class="w">
    </span><span class="no">eqb</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="kr">fun</span><span class="w"> </span><span class="o">(</span><span class="no">f1</span><span class="w"> </span><span class="no">f2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">bool</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">bool</span><span class="o">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w">
      </span><span class="o">(</span><span class="no">f1</span><span class="w"> </span><span class="no">true</span><span class="o">)</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="o">(</span><span class="no">f2</span><span class="w"> </span><span class="no">true</span><span class="o">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">(</span><span class="no">f1</span><span class="w"> </span><span class="no">false</span><span class="o">)</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="o">(</span><span class="no">f2</span><span class="w"> </span><span class="no">false</span><span class="o">)</span><span class="w"> 
  </span><span class="o">}.</span><span class="w">

</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">id</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="no">id</span><span class="o">).</span><span class="w">      </span><span class="c">(* ==&gt; true *)</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">negb</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="no">negb</span><span class="o">).</span><span class="w">  </span><span class="c">(* ==&gt; true *)</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">id</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="no">negb</span><span class="o">).</span><span class="w">    </span><span class="c">(* ==&gt; false *)</span><span class="w">
</span></code></pre></div></div>

<p>这里这个 <code class="language-plaintext highlighter-rouge">eqb</code> 的定义也是基于 extensionality 的定义，如果考虑到 effects（divergence、IO）是很容易 break 的（类似 parametricity）</p>

<h3 id="parameterized-instances-new-typeclasses-from-old">Parameterized Instances: New Typeclasses from Old</h3>

<p>Structural recursion</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Instance</span><span class="w"> </span><span class="no">showPair</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="o">}</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">Show</span><span class="w"> </span><span class="no">B</span><span class="o">}</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="no">B</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">{</span><span class="w">
    </span><span class="no">show</span><span class="w"> </span><span class="no">p</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
      </span><span class="kr">let</span><span class="w"> </span><span class="o">(</span><span class="no">a</span><span class="o">,</span><span class="no">b</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">p</span><span class="w"> </span><span class="kr">in</span><span class="w"> 
        </span><span class="s2">"("</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s2">","</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="no">b</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="s2">")"</span><span class="w">
  </span><span class="o">}.</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">show</span><span class="w"> </span><span class="o">(</span><span class="no">true</span><span class="o">,</span><span class="mi">42</span><span class="o">)).</span><span class="w">
</span></code></pre></div></div>

<p>Structural equality</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Instance</span><span class="w"> </span><span class="no">eqPair</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">Eq</span><span class="w"> </span><span class="no">A</span><span class="o">}</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">Eq</span><span class="w"> </span><span class="no">B</span><span class="o">}</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Eq</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="no">B</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">{</span><span class="w">
    </span><span class="no">eqb</span><span class="w"> </span><span class="no">p1</span><span class="w"> </span><span class="no">p2</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
      </span><span class="kr">let</span><span class="w"> </span><span class="o">(</span><span class="no">p1a</span><span class="o">,</span><span class="no">p1b</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">p1</span><span class="w"> </span><span class="kr">in</span><span class="w">
      </span><span class="kr">let</span><span class="w"> </span><span class="o">(</span><span class="no">p2a</span><span class="o">,</span><span class="no">p2b</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">p2</span><span class="w"> </span><span class="kr">in</span><span class="w">
      </span><span class="no">andb</span><span class="w"> </span><span class="o">(</span><span class="no">p1a</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="no">p2a</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">p1b</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="no">p2b</span><span class="o">)</span><span class="w">
  </span><span class="o">}.</span><span class="w">
</span></code></pre></div></div>

<p>Slightly more complicated example: typical list:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(* the book didn't use any from ListNotation *)</span><span class="w">
</span><span class="k">Fixpoint</span><span class="w"> </span><span class="no">showListAux</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">s</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">string</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">l</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">string</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">match</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="kp">with</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="no">nil</span><span class="w"> </span><span class="p">⇒</span><span class="w"> </span><span class="s2">""</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="no">cons</span><span class="w"> </span><span class="no">h</span><span class="w"> </span><span class="no">nil</span><span class="w"> </span><span class="p">⇒</span><span class="w"> </span><span class="no">s</span><span class="w"> </span><span class="no">h</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="no">cons</span><span class="w"> </span><span class="no">h</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="p">⇒</span><span class="w"> </span><span class="no">append</span><span class="w"> </span><span class="o">(</span><span class="no">append</span><span class="w"> </span><span class="o">(</span><span class="no">s</span><span class="w"> </span><span class="no">h</span><span class="o">)</span><span class="w"> </span><span class="s2">", "</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">showListAux</span><span class="w"> </span><span class="no">s</span><span class="w"> </span><span class="no">t</span><span class="o">)</span><span class="w">
  </span><span class="kr">end</span><span class="pi">.</span><span class="w">
</span><span class="k">Instance</span><span class="w"> </span><span class="no">showList</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="o">}</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="o">(</span><span class="no">list</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">{</span><span class="w">
    </span><span class="no">show</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">append</span><span class="w"> </span><span class="s2">"["</span><span class="w"> </span><span class="o">(</span><span class="no">append</span><span class="w"> </span><span class="o">(</span><span class="no">showListAux</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="no">l</span><span class="o">)</span><span class="w"> </span><span class="s2">"]"</span><span class="o">)</span><span class="w">
  </span><span class="o">}.</span><span class="w">
  
</span><span class="c">(* I used them though *)</span><span class="w">
</span><span class="k">Fixpoint</span><span class="w"> </span><span class="no">eqListAux</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">Eq</span><span class="w"> </span><span class="no">A</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">l1</span><span class="w"> </span><span class="no">l2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">bool</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">match</span><span class="w"> </span><span class="no">l1</span><span class="o">,</span><span class="w"> </span><span class="no">l2</span><span class="w"> </span><span class="kp">with</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="no">nil</span><span class="o">,</span><span class="w"> </span><span class="no">nil</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">true</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="o">(</span><span class="no">h1</span><span class="p">::</span><span class="no">t1</span><span class="o">),</span><span class="w"> </span><span class="o">(</span><span class="no">h2</span><span class="p">::</span><span class="no">t2</span><span class="o">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">(</span><span class="no">h1</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="no">h2</span><span class="o">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">(</span><span class="no">eqListAux</span><span class="w"> </span><span class="no">t1</span><span class="w"> </span><span class="no">t2</span><span class="o">)</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="p">_</span><span class="o">,</span><span class="w"> </span><span class="p">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">false</span><span class="w">
  </span><span class="kr">end</span><span class="pi">.</span><span class="w">

</span><span class="k">Instance</span><span class="w"> </span><span class="no">eqList</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">Eq</span><span class="w"> </span><span class="no">A</span><span class="o">}</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Eq</span><span class="w"> </span><span class="o">(</span><span class="no">list</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">{</span><span class="w">
    </span><span class="no">eqb</span><span class="w"> </span><span class="no">l1</span><span class="w"> </span><span class="no">l2</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">eqListAux</span><span class="w"> </span><span class="no">l1</span><span class="w"> </span><span class="no">l2</span><span class="w">
  </span><span class="o">}.</span><span class="w">
</span></code></pre></div></div>

<h3 id="class-hierarchies">Class Hierarchies</h3>

<blockquote>
  <p>we might want a typeclass <code class="language-plaintext highlighter-rouge">Ord</code> for “ordered types” that support both equality and a less-or-equal comparison operator.</p>
</blockquote>

<p>A bad way would be declare a new class with two func <code class="language-plaintext highlighter-rouge">eq</code> and <code class="language-plaintext highlighter-rouge">le</code>.</p>

<p>It’s better to establish dependencies between typeclasses, similar with OOP <code class="language-plaintext highlighter-rouge">class</code> inheritence and subtyping (but better!), this gave good code reuses.</p>

<blockquote>
  <p>We often want to organize typeclasses into hierarchies.</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Class</span><span class="w"> </span><span class="no">Ord</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">Eq</span><span class="w"> </span><span class="no">A</span><span class="o">}</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">{</span><span class="w">
    </span><span class="no">le</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">bool</span><span class="w">
  </span><span class="o">}.</span><span class="w">
</span><span class="k">Check</span><span class="w"> </span><span class="no">Ord</span><span class="pi">.</span><span class="w"> </span><span class="c">(* ==&gt;
Ord
     : forall A : Type, Eq A -&gt; Type
*)</span><span class="w">
</span></code></pre></div></div>

<p>class <code class="language-plaintext highlighter-rouge">Eq</code> is a “super(type)class” of <code class="language-plaintext highlighter-rouge">Ord</code> (not to be confused with OOP superclass)</p>

<p>This is <em>Sub-typeclassing</em>.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Fixpoint</span><span class="w"> </span><span class="no">listOrdAux</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">Ord</span><span class="w"> </span><span class="no">A</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">l1</span><span class="w"> </span><span class="no">l2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">bool</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> 
  </span><span class="kr">match</span><span class="w"> </span><span class="no">l1</span><span class="o">,</span><span class="w"> </span><span class="no">l2</span><span class="w"> </span><span class="kp">with</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="o">[],</span><span class="w"> </span><span class="p">_</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="p">_</span><span class="o">,</span><span class="w"> </span><span class="o">[]</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">false</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">h1</span><span class="p">::</span><span class="no">t1</span><span class="o">,</span><span class="w"> </span><span class="no">h2</span><span class="p">::</span><span class="no">t2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="o">(</span><span class="no">h1</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="no">h2</span><span class="o">)</span><span class="w">
                     </span><span class="kr">then</span><span class="w"> </span><span class="o">(</span><span class="no">listOrdAux</span><span class="w"> </span><span class="no">t1</span><span class="w"> </span><span class="no">t2</span><span class="o">)</span><span class="w">
                     </span><span class="kr">else</span><span class="w"> </span><span class="o">(</span><span class="no">le</span><span class="w"> </span><span class="no">h1</span><span class="w"> </span><span class="no">h2</span><span class="o">)</span><span class="w">
  </span><span class="kr">end</span><span class="pi">.</span><span class="w">

</span><span class="k">Instance</span><span class="w"> </span><span class="no">listOrd</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">Ord</span><span class="w"> </span><span class="no">A</span><span class="o">}</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Ord</span><span class="w"> </span><span class="o">(</span><span class="no">list</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">{</span><span class="w">
    </span><span class="no">le</span><span class="w"> </span><span class="no">l1</span><span class="w"> </span><span class="no">l2</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">listOrdAux</span><span class="w"> </span><span class="no">l1</span><span class="w"> </span><span class="no">l2</span><span class="w">
  </span><span class="o">}.</span><span class="w">

</span><span class="c">(* truthy *)</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">le</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="mi">2</span><span class="o">]).</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">le</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="mi">2</span><span class="p">;</span><span class="mi">2</span><span class="o">]).</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">le</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="mi">2</span><span class="o">]).</span><span class="w">

</span><span class="c">(* falsy *)</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">le</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">]).</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">le</span><span class="w"> </span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="o">]).</span><span class="w">
</span></code></pre></div></div>

<h2 id="how-it-works">How It works</h2>

<h3 id="implicit-generalization">Implicit Generalization</h3>

<p>所以 <code class="language-plaintext highlighter-rouge">`{...}</code> 这个 “backtick” notation is called <em>implicit generalization</em>，比 implicit <code class="language-plaintext highlighter-rouge">{}</code> 多做了一件自动 generalize 泛化 free varabile 的事情。</p>

<blockquote>
  <p>that was added to Coq to support typeclasses but that can also be used to good effect elsewhere.</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">showOne1</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">a</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">string</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="s2">"The value is "</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="no">a</span><span class="pi">.</span><span class="w">

</span><span class="k">Print</span><span class="w"> </span><span class="no">showOne1</span><span class="pi">.</span><span class="w">
</span><span class="c">(* ==&gt;
    showOne1 = 
      fun (A : Type) (H : Show A) (a : A) =&gt; "The value is " ++ show a
           : forall A : Type, Show A -&gt; A -&gt; string

    Arguments A, H are implicit and maximally inserted
*)</span><span class="w">
</span></code></pre></div></div>

<blockquote>
  <p>notice that the occurrence of <code class="language-plaintext highlighter-rouge">A</code> inside the <code class="language-plaintext highlighter-rouge">`{...}</code> is unbound and automatically insert the binding that we wrote explicitly before.</p>
</blockquote>

<blockquote>
  <p>The “implicit and maximally generalized” annotation on the last line means that the automatically inserted bindings are treated (注：printed) as if they had been written with <code class="language-plaintext highlighter-rouge">{...}</code>, rather than <code class="language-plaintext highlighter-rouge">(...)</code>.</p>
</blockquote>

<blockquote>
  <p>The “implicit” part means that the type argument <code class="language-plaintext highlighter-rouge">A</code> and the <code class="language-plaintext highlighter-rouge">Show</code> witness <code class="language-plaintext highlighter-rouge">H</code> are usually expected to be left implicit<br />
whenever we write <code class="language-plaintext highlighter-rouge">showOne1</code>, Coq will automatically insert two <em>unification variables</em> as the first two arguments.</p>
</blockquote>

<blockquote>
  <p>This automatic insertion can be disabled by writing <code class="language-plaintext highlighter-rouge">@</code>, so a bare occurrence of <code class="language-plaintext highlighter-rouge">showOne1</code> means the same as <code class="language-plaintext highlighter-rouge">@showOne1 _ _</code></p>
</blockquote>

<p>这里的 witness <code class="language-plaintext highlighter-rouge">H</code> 即 <code class="language-plaintext highlighter-rouge">A</code> implements <code class="language-plaintext highlighter-rouge">Show</code> 的 evidence，本质就是个 table or record，可以 written more explicitly:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">showOne2</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="p">_</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">a</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">string</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="s2">"The value is "</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="no">a</span><span class="pi">.</span><span class="w">

</span><span class="k">Definition</span><span class="w"> </span><span class="no">showOne3</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">H</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">a</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">string</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="s2">"The value is "</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="no">a</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>甚至</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">showOne4</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">Show</span><span class="o">}</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">string</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="s2">"The value is "</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="no">a</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">showOne</span><span class="w"> </span><span class="o">=</span><span class="w"> 
</span><span class="kr">fun</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">H</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">a</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s2">"The value is "</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="no">a</span><span class="w">
     </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">,</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">string</span><span class="w">

</span><span class="k">Set</span><span class="w"> </span><span class="k">Printing</span><span class="w"> </span><span class="k">Implicit</span><span class="pi">.</span><span class="w">

</span><span class="no">showOne</span><span class="w"> </span><span class="o">=</span><span class="w"> 
</span><span class="kr">fun</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">H</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">a</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="s2">"The value is "</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="o">@</span><span class="no">show</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="no">H</span><span class="w"> </span><span class="no">a</span><span class="w">     </span><span class="c">(* &lt;-- 注意这里 *)</span><span class="w">
     </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">,</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">string</span><span class="w">
</span></code></pre></div></div>

<h4 id="vs-haskell">vs. Haskell</h4>

<p>顺便，Haskell 的话，<code class="language-plaintext highlighter-rouge">Show</code> 是可以直接 inferred from the use of <code class="language-plaintext highlighter-rouge">show</code> 得</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">showOne</span> <span class="n">a</span> <span class="o">=</span> <span class="n">show</span> <span class="n">a</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="o">:</span><span class="n">t</span> <span class="n">showOne</span>
<span class="n">showOne</span> <span class="o">::</span> <span class="kt">Show</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">String</span>
</code></pre></div></div>

<p>但是 Coq 不行，会退化上「上一个定义的 instance Show」，还挺奇怪的（</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">showOne5</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">string</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">  </span><span class="c">(* not generalized *)</span><span class="w">
  </span><span class="s2">"The value is "</span><span class="w"> </span><span class="o">++</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="no">a</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<h4 id="free-superclass-instance">Free Superclass Instance</h4>

<p>``{Ord A}<code class="language-plaintext highlighter-rouge"> led Coq to fill in both </code>A<code class="language-plaintext highlighter-rouge"> and </code>H : Eq A<code class="language-plaintext highlighter-rouge"> because it's the superclass of </code>Ord` (appears as the second argument).</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">max1</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">Ord</span><span class="w"> </span><span class="no">A</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">if</span><span class="w"> </span><span class="no">le</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="no">x</span><span class="pi">.</span><span class="w">

</span><span class="k">Set</span><span class="w"> </span><span class="k">Printing</span><span class="w"> </span><span class="k">Implicit</span><span class="pi">.</span><span class="w">
</span><span class="k">Print</span><span class="w"> </span><span class="no">max1</span><span class="pi">.</span><span class="w">
</span><span class="c">(* ==&gt;
     max1 = 
       fun (A : Type) (H : Eq A) (H0 : @Ord A H) (x y : A) =&gt;
         if @le A H H0 x y then y else x

   : forall (A : Type) (H : Eq A), 
       @Ord A H -&gt; A -&gt; A -&gt; A    
*)</span><span class="w">
</span><span class="k">Check</span><span class="w"> </span><span class="no">Ord</span><span class="pi">.</span><span class="w">
</span><span class="c">(* ==&gt; Ord : forall A : Type, Eq A -&gt; Type *)</span><span class="w">
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Ord</code> type 写详细的话可以是：</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Ord</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">),</span><span class="w"> </span><span class="o">(</span><span class="no">H</span><span class="p">:</span><span class="w"> </span><span class="no">Eq</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="kr">Type</span><span class="w">
</span></code></pre></div></div>

<h4 id="other-usages-of-">Other usages of <code class="language-plaintext highlighter-rouge">`{}</code></h4>

<p>Implicit generalized <code class="language-plaintext highlighter-rouge">Prop</code> mentioning free vars.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Generalizable</span><span class="w"> </span><span class="k">Variables</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="pi">.</span><span class="w">

</span><span class="k">Lemma</span><span class="w"> </span><span class="no">commutativity_property</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">x</span><span class="o">}.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w"> </span><span class="kp">intros</span><span class="pi">.</span><span class="w"> </span><span class="ne">omega</span><span class="pi">.</span><span class="w"> </span><span class="k">Qed</span><span class="pi">.</span><span class="w">

</span><span class="k">Check</span><span class="w"> </span><span class="no">commutativity_property</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>Implicit generalized <code class="language-plaintext highlighter-rouge">fun</code>/<code class="language-plaintext highlighter-rouge">λ</code>, however…</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">implicit_fun</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="err">`</span><span class="o">{</span><span class="no">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">y</span><span class="o">}.</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">implicit_fun</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="o">)</span><span class="w">  </span><span class="c">(* ==&gt; Error *)</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(@</span><span class="no">implicit_fun</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="o">)</span><span class="w">
</span></code></pre></div></div>

<p>Implicitly-generalized but inserted as explicit via <code class="language-plaintext highlighter-rouge">`(...)</code></p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">implicit_fun</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="err">`</span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">y</span><span class="o">).</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">implicit_fun</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="o">)</span><span class="w">
</span></code></pre></div></div>

<p>这里可以看到 Coq 的所有语法都是正交的（非常牛逼……）</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">()</code>/<code class="language-plaintext highlighter-rouge">{}</code> 控制是否是 implicit argument</li>
  <li><code class="language-plaintext highlighter-rouge">`</code>-prefix 控制是否做 implicit generalization
    <ul>
      <li>N.B. 可能你忘记了但是 <code class="language-plaintext highlighter-rouge">→</code> is degenerated <code class="language-plaintext highlighter-rouge">∀</code> (<code class="language-plaintext highlighter-rouge">Π</code>)，所以 generalization 自然会生成 <code class="language-plaintext highlighter-rouge">fun</code></li>
    </ul>
  </li>
</ul>

<h3 id="records-are-products">Records are Products</h3>

<blockquote>
  <p>Record types must be declared before they are used. For example:</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Record</span><span class="w"> </span><span class="no">Point</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="no">Build_Point</span><span class="w">
    </span><span class="o">{</span><span class="w">
      </span><span class="no">px</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="p">;</span><span class="w">
      </span><span class="no">py</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="w">
    </span><span class="o">}.</span><span class="w">

</span><span class="c">(* built with constructor *)</span><span class="w">
</span><span class="k">Check</span><span class="w"> </span><span class="o">(</span><span class="no">Build_Point</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">4</span><span class="o">).</span><span class="w">

</span><span class="c">(* built with record syntax *)</span><span class="w">
</span><span class="k">Check</span><span class="w"> </span><span class="o">{|</span><span class="w"> </span><span class="no">px</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="no">py</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">|}.</span><span class="w">
</span><span class="k">Check</span><span class="w"> </span><span class="o">{|</span><span class="w"> </span><span class="no">py</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="no">px</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">|}.</span><span class="w">

</span><span class="c">(* field access, with a clunky "dot notation" *)</span><span class="w">
</span><span class="k">Definition</span><span class="w"> </span><span class="no">r</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Point</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">{|</span><span class="w"> </span><span class="no">px</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="no">py</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">|}.</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">r</span><span class="o">.(</span><span class="no">px</span><span class="o">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">r</span><span class="o">.(</span><span class="no">py</span><span class="o">)).</span><span class="w">
</span></code></pre></div></div>

<p>和 OCaml 一样是 nominal typing 而非 structural typing。
类似于 OCaml 中的 record 其实到 backend 了就会和 tuple 等价：都会 lower 到 Heap Block），
Coq 中的 Record 其实和 Pair/Product 也是等价：都是 arity 为 2 的 Inductive type：</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Inductive</span><span class="w"> </span><span class="no">Point</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Set</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> 
  </span><span class="o">|</span><span class="w"> </span><span class="no">Build_Point</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">Point</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>我仿造 <code class="language-plaintext highlighter-rouge">Print px.</code> 输出的定义模拟了一下：</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Inductive</span><span class="w"> </span><span class="no">Point2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Set</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> 
  </span><span class="o">|</span><span class="w"> </span><span class="no">Build_Point2</span><span class="w"> </span><span class="o">(</span><span class="no">px2</span><span class="p">:</span><span class="no">nat</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">py2</span><span class="p">:</span><span class="no">nat</span><span class="o">).</span><span class="w">
</span><span class="k">Definition</span><span class="w"> </span><span class="no">px2</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="kr">fun</span><span class="w"> </span><span class="no">p</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Point2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="o">(</span><span class="no">px</span><span class="o">,</span><span class="w"> </span><span class="p">_</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">p</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">px</span><span class="pi">.</span><span class="w">
</span><span class="k">Definition</span><span class="w"> </span><span class="no">py2</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="kr">fun</span><span class="w"> </span><span class="no">p</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Point2</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kr">let</span><span class="w"> </span><span class="o">(</span><span class="p">_</span><span class="o">,</span><span class="w"> </span><span class="no">py</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">p</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">py</span><span class="pi">.</span><span class="w">

</span><span class="k">Definition</span><span class="w"> </span><span class="no">r2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Point2</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">Build_Point2</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">4</span><span class="o">.</span><span class="w">
</span><span class="k">Compute</span><span class="w"> </span><span class="o">(</span><span class="no">r2</span><span class="o">.(</span><span class="no">px2</span><span class="o">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">r2</span><span class="o">.(</span><span class="no">py2</span><span class="o">)).</span><span class="w">                        </span><span class="c">(* =&gt; 6 *)</span><span class="w">

</span><span class="k">Definition</span><span class="w"> </span><span class="no">r2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Point2</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">{|</span><span class="w"> </span><span class="no">px2</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="no">py2</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">|}.</span><span class="w">   </span><span class="c">(* Error: px2 is not a projection *)</span><span class="w">
</span></code></pre></div></div>

<p>可以发现 dot notation 是可以工作的，<code class="language-plaintext highlighter-rouge">.</code> 应该只是一个 pipe
但是 <code class="language-plaintext highlighter-rouge">{|...|}</code> 不知道为什么这里会认为 <code class="language-plaintext highlighter-rouge">px2</code> 不是一个 record projection.</p>

<blockquote>
  <p>Note that the field names have to be different. Any given field name can belong to only one record type. 
This greatly simplifies type inference!</p>
</blockquote>

<h3 id="typeclasses-are-records">Typeclasses are Records</h3>

<blockquote>
  <p>Typeclasses and instances, in turn, are basically just syntactic sugar for record types and values (together with a bit of magic for using proof search to fill in appropriate instances during typechecking…</p>
</blockquote>

<blockquote>
  <p>Internally, a typeclass declaration is elaborated into a <em>parameterized</em> <code class="language-plaintext highlighter-rouge">Record</code> declaration:</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Class</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">string</span><span class="w"> </span><span class="o">}.</span><span class="w">

</span><span class="k">Print</span><span class="w"> </span><span class="no">Show</span><span class="pi">.</span><span class="w">
</span><span class="k">Record</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> 
    </span><span class="no">Build_Show</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">string</span><span class="w"> </span><span class="o">}</span><span class="w">

</span><span class="k">Set</span><span class="w"> </span><span class="k">Printing</span><span class="w"> </span><span class="k">All</span><span class="pi">.</span><span class="w">
</span><span class="k">Print</span><span class="w"> </span><span class="no">Show</span><span class="pi">.</span><span class="w">
</span><span class="no">Variant</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
    </span><span class="no">Build_Show</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="p">_</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="p">_</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">,</span><span class="w"> </span><span class="no">string</span><span class="o">,</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="w">

</span><span class="c">(* to make it more clear... *)</span><span class="w">
</span><span class="k">Inductive</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">Build_Show</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="o">(</span><span class="no">show</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="o">(</span><span class="no">a</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">),</span><span class="w"> </span><span class="no">string</span><span class="o">),</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="w">
  
</span><span class="c">(* or more GADT looking, i.e., implicit generalized *)</span><span class="w">
</span><span class="k">Inductive</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">Build_Show</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">string</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="w">
</span></code></pre></div></div>

<p>Coq actually call a single-field record <code class="language-plaintext highlighter-rouge">Variant</code>. 
Well actually, I found it’s for any single-constructor <code class="language-plaintext highlighter-rouge">Inductive</code>ly constructed type. 
You can even use <code class="language-plaintext highlighter-rouge">Variant</code> nonchangbly with <code class="language-plaintext highlighter-rouge">Inductive</code> as a keyword…</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Set</span><span class="w"> </span><span class="k">Printing</span><span class="w"> </span><span class="k">All</span><span class="pi">.</span><span class="w">
</span><span class="k">Print</span><span class="w"> </span><span class="no">Point</span><span class="pi">.</span><span class="w">
</span><span class="no">Variant</span><span class="w"> </span><span class="no">Point</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Set</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
    </span><span class="no">Build_Point</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="o">(</span><span class="p">_</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="p">_</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">),</span><span class="w"> </span><span class="no">Point</span><span class="w">
</span></code></pre></div></div>

<blockquote>
  <p>Analogously, Instance declarations become record values:</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Print</span><span class="w"> </span><span class="no">showNat</span><span class="pi">.</span><span class="w">
</span><span class="no">showNat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{|</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">string_of_nat</span><span class="w"> </span><span class="o">|}</span><span class="w">
    </span><span class="p">:</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">nat</span><span class="w">
</span></code></pre></div></div>

<blockquote>
  <p>Similarly, overloaded functions like show are really just <em>record projections</em>, which in turn are just functions that select a particular argument of a one-constructor Inductive type.</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Print</span><span class="w"> </span><span class="no">show</span><span class="pi">.</span><span class="w">
</span><span class="no">show</span><span class="w"> </span><span class="o">=</span><span class="w"> 
  </span><span class="kr">fun</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">Show0</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> 
    </span><span class="kr">let</span><span class="w"> </span><span class="o">(</span><span class="no">show</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">Show0</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">show</span><span class="w">
      </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">,</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">string</span><span class="w">

</span><span class="k">Set</span><span class="w"> </span><span class="k">Printing</span><span class="w"> </span><span class="k">All</span><span class="pi">.</span><span class="w">
</span><span class="k">Print</span><span class="w"> </span><span class="no">show</span><span class="pi">.</span><span class="w">
</span><span class="no">show</span><span class="w"> </span><span class="o">=</span><span class="w"> 
  </span><span class="kr">fun</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">Show0</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w">
    </span><span class="kr">match</span><span class="w"> </span><span class="no">Show0</span><span class="w"> </span><span class="kr">return</span><span class="w"> </span><span class="o">(</span><span class="kr">forall</span><span class="w"> </span><span class="p">_</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">,</span><span class="w"> </span><span class="no">string</span><span class="o">)</span><span class="w"> </span><span class="kp">with</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="no">Build_Show</span><span class="w"> </span><span class="p">_</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">show</span><span class="w">
    </span><span class="kr">end</span><span class="w">
      </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="p">_</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="p">_</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">),</span><span class="w"> </span><span class="no">string</span><span class="w">
</span></code></pre></div></div>

<h3 id="inferring-instances">Inferring Instances</h3>

<blockquote>
  <p>appropriate instances are automatically inferred (and/or constructed!) during typechecking.</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">eg42</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">show</span><span class="w"> </span><span class="mi">42</span><span class="o">.</span><span class="w">

</span><span class="k">Set</span><span class="w"> </span><span class="k">Printing</span><span class="w"> </span><span class="k">Implicit</span><span class="pi">.</span><span class="w">
</span><span class="k">Print</span><span class="w"> </span><span class="no">eg42</span><span class="pi">.</span><span class="w">
</span><span class="no">eg42</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">@</span><span class="no">show</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="no">showNat</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">string</span><span class="w">
</span></code></pre></div></div>

<p>different with <code class="language-plaintext highlighter-rouge">Compute</code>, <code class="language-plaintext highlighter-rouge">Print</code> 居然还可以这么把所有 implicit argument (after inferred) 都给 print 出来……</p>

<p>type inferrence:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">show</code> is expanded to <code class="language-plaintext highlighter-rouge">@show _ _ 42</code></li>
  <li>obviously it’s <code class="language-plaintext highlighter-rouge">@show nat __42</code></li>
  <li>obviously it’s <code class="language-plaintext highlighter-rouge">@show nat (?H : Show Nat) 42</code></li>
</ul>

<p>Okay now where to find this witness/evidence/instance/record/table/you-name-it <code class="language-plaintext highlighter-rouge">?H</code></p>

<blockquote>
  <p>It attempts to find or construct such a value using a <em>variant of the <code class="language-plaintext highlighter-rouge">eauto</code> proof search</em> procedure that refers to a “hint database” called <code class="language-plaintext highlighter-rouge">typeclass_instances</code>.</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Print</span><span class="w"> </span><span class="no">HintDb</span><span class="w"> </span><span class="no">typeclass_instances</span><span class="pi">.</span><span class="w">  </span><span class="c">(* too much to be useful *)</span><span class="w">
</span></code></pre></div></div>

<p>“hint database” to me is better understood as a reverse of environment or typing context <code class="language-plaintext highlighter-rouge">Γ</code>. Though specialized with only <code class="language-plaintext highlighter-rouge">Instance</code> there.
（这么一看实现一个 Scala 的 <code class="language-plaintext highlighter-rouge">Implicit</code> 也不难啊）</p>

<p>Coq can even print what’s happening during this proof search!</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">Set</span><span class="w"> </span><span class="no">Typeclasses</span><span class="w"> </span><span class="no">Debug</span><span class="pi">.</span><span class="w">
</span><span class="k">Check</span><span class="w"> </span><span class="o">(</span><span class="no">show</span><span class="w"> </span><span class="mi">42</span><span class="o">).</span><span class="w">
</span><span class="c">(* ==&gt;
     Debug: 1: looking for (Show nat) without backtracking
     Debug: 1.1: exact showNat on (Show nat), 0 subgoal(s)
*)</span><span class="w">

</span><span class="k">Check</span><span class="w"> </span><span class="o">(</span><span class="no">show</span><span class="w"> </span><span class="o">(</span><span class="no">true</span><span class="o">,</span><span class="mi">42</span><span class="o">)).</span><span class="w">
</span><span class="c">(* ==&gt;
     Debug: 1: looking for (Show (bool * nat)) without backtracking
     Debug: 1.1: simple apply @showPair on (Show (bool * nat)), 2 subgoal(s)
     Debug: 1.1.3 : (Show bool)
     Debug: 1.1.3: looking for (Show bool) without backtracking
     Debug: 1.1.3.1: exact showBool on (Show bool), 0 subgoal(s)
     Debug: 1.1.3 : (Show nat)
     Debug: 1.1.3: looking for (Show nat) without backtracking
     Debug: 1.1.3.1: exact showNat on (Show nat), 0 subgoal(s)      *)</span><span class="w">
</span><span class="no">Unset</span><span class="w"> </span><span class="no">Typeclasses</span><span class="w"> </span><span class="no">Debug</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<blockquote>
  <p>In summary, here are the steps again:</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">show</span><span class="w"> </span><span class="mi">42</span><span class="w">
    </span><span class="o">===&gt;</span><span class="w">   </span><span class="o">{</span><span class="w"> </span><span class="no">Implicit</span><span class="w"> </span><span class="no">arguments</span><span class="w"> </span><span class="o">}</span><span class="w">
</span><span class="o">@</span><span class="no">show</span><span class="w"> </span><span class="p">_</span><span class="w"> </span><span class="p">_</span><span class="w"> </span><span class="mi">42</span><span class="w">
    </span><span class="o">===&gt;</span><span class="w">   </span><span class="o">{</span><span class="w"> </span><span class="no">Typing</span><span class="w"> </span><span class="o">}</span><span class="w">
</span><span class="o">@</span><span class="no">show</span><span class="w"> </span><span class="o">(</span><span class="nv">?A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="nv">?Show0</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="nv">?A</span><span class="o">)</span><span class="w"> </span><span class="mi">42</span><span class="w">
    </span><span class="o">===&gt;</span><span class="w">   </span><span class="o">{</span><span class="w"> </span><span class="no">Unification</span><span class="w"> </span><span class="o">}</span><span class="w">
</span><span class="o">@</span><span class="no">show</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="o">(</span><span class="nv">?Show0</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">nat</span><span class="o">)</span><span class="w"> </span><span class="mi">42</span><span class="w">
    </span><span class="o">===&gt;</span><span class="w">   </span><span class="o">{</span><span class="w"> </span><span class="k">Proof</span><span class="w"> </span><span class="no">search</span><span class="w"> </span><span class="no">for</span><span class="w"> </span><span class="no">Show</span><span class="w"> </span><span class="no">Nat</span><span class="w"> </span><span class="no">returns</span><span class="w"> </span><span class="no">showNat</span><span class="w"> </span><span class="o">}</span><span class="w">
</span><span class="o">@</span><span class="no">show</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="no">showNat</span><span class="w"> </span><span class="mi">42</span><span class="w">
</span></code></pre></div></div>

<h2 id="typeclasses-and-proofs">Typeclasses and Proofs</h2>

<h3 id="propositional-typeclass-members">Propositional Typeclass Members</h3>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Class</span><span class="w"> </span><span class="no">EqDec</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="o">{</span><span class="no">H</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Eq</span><span class="w"> </span><span class="no">A</span><span class="o">}</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> 
  </span><span class="o">{</span><span class="w"> 
    </span><span class="no">eqb_eq</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="o">,</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">true</span><span class="w"> </span><span class="p">↔</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">y</span><span class="w"> 
  </span><span class="o">}.</span><span class="w">
</span></code></pre></div></div>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Instance</span><span class="w"> </span><span class="no">eqdecNat</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">EqDec</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> 
  </span><span class="o">{</span><span class="w">
    </span><span class="no">eqb_eq</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="nn">Nat</span><span class="p">.</span><span class="no">eqb_eq</span><span class="w">
  </span><span class="o">}.</span><span class="w">
</span></code></pre></div></div>

<p>这里可以用于抽象 LF-07 的 reflection</p>

<h3 id="substructures">Substructures</h3>

<blockquote>
  <p>Naturally, it is also possible to have typeclass instances as members of other typeclasses: these are called <em>substructures</em>.</p>
</blockquote>

<p>这里的 <code class="language-plaintext highlighter-rouge">relation</code> 来自 Prelude 不过和 LF-11 用法一样：</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Require</span><span class="w"> </span><span class="k">Import</span><span class="w"> </span><span class="nn">Coq</span><span class="p">.</span><span class="nn">Relations</span><span class="p">.</span><span class="no">Relation_Definitions</span><span class="pi">.</span><span class="w">
</span><span class="k">Class</span><span class="w"> </span><span class="no">Reflexive</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">R</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">relation</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">{</span><span class="w"> 
    </span><span class="ne">reflexivity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="w"> </span><span class="no">x</span><span class="o">,</span><span class="w"> </span><span class="no">R</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">x</span><span class="w">
  </span><span class="o">}.</span><span class="w">
</span><span class="k">Class</span><span class="w"> </span><span class="no">Transitive</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">R</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">relation</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">{</span><span class="w">
    </span><span class="kp">transitivity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="no">z</span><span class="o">,</span><span class="w"> </span><span class="no">R</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">R</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="no">z</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">R</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">z</span><span class="w">
  </span><span class="o">}.</span><span class="w">
</span></code></pre></div></div>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Class</span><span class="w"> </span><span class="no">PreOrder</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">R</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">relation</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">{</span><span class="w"> </span><span class="no">PreOrder_Reflexive</span><span class="w"> </span><span class="p">:</span><span class="o">&gt;</span><span class="w"> </span><span class="no">Reflexive</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="no">R</span><span class="w"> </span><span class="p">;</span><span class="w">
    </span><span class="no">PreOrder_Transitive</span><span class="w"> </span><span class="p">:</span><span class="o">&gt;</span><span class="w"> </span><span class="no">Transitive</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="no">R</span><span class="w"> </span><span class="o">}.</span><span class="w">
</span></code></pre></div></div>

<blockquote>
  <p>The syntax <code class="language-plaintext highlighter-rouge">:&gt;</code> indicates that each <code class="language-plaintext highlighter-rouge">PreOrder</code> can be seen as a <code class="language-plaintext highlighter-rouge">Reflexive</code> and <code class="language-plaintext highlighter-rouge">Transitive</code> relation, so that, any time a reflexive relation is needed, a preorder can be used instead.</p>
</blockquote>

<p>这里的 <code class="language-plaintext highlighter-rouge">:&gt;</code> 方向和 subtyping 的 <em>subsumption</em> 是反着的……跟 SML 的 ascription <code class="language-plaintext highlighter-rouge">:&gt;</code> 一样……</p>

<ul>
  <li>subtyping  <code class="language-plaintext highlighter-rouge">T :&gt; S</code> : value of <code class="language-plaintext highlighter-rouge">S</code> can safely be used as value of <code class="language-plaintext highlighter-rouge">T</code></li>
  <li>ascription <code class="language-plaintext highlighter-rouge">P :&gt; R</code> : value of <code class="language-plaintext highlighter-rouge">P</code> can safely be used as value of <code class="language-plaintext highlighter-rouge">R</code></li>
</ul>

<p>Why?</p>

<h2 id="some-useful-typeclasses">Some Useful Typeclasses</h2>

<h3 id="dec"><code class="language-plaintext highlighter-rouge">Dec</code></h3>

<blockquote>
  <p>The <code class="language-plaintext highlighter-rouge">ssreflect</code> library defines what it means for a proposition <code class="language-plaintext highlighter-rouge">P</code> to be <em>decidable</em> like this…</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Require</span><span class="w"> </span><span class="k">Import</span><span class="w"> </span><span class="no">ssreflect</span><span class="w"> </span><span class="no">ssrbool</span><span class="pi">.</span><span class="w">
</span><span class="k">Print</span><span class="w"> </span><span class="no">decidable</span><span class="pi">.</span><span class="w">
</span><span class="c">(* ==&gt;
     decidable = fun P : Prop =&gt; {P} + {~ P}
*)</span><span class="w">
</span></code></pre></div></div>

<blockquote>
  <p>.. where <code class="language-plaintext highlighter-rouge">{P} + {¬ P}</code> is an “informative disjunction” of <code class="language-plaintext highlighter-rouge">P</code> and <code class="language-plaintext highlighter-rouge">¬P</code>.</p>
</blockquote>

<p>即两个 evidence（参考 LF-07)</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Class</span><span class="w"> </span><span class="no">Dec</span><span class="w"> </span><span class="o">(</span><span class="no">P</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="o">{</span><span class="w">
    </span><span class="no">dec</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">decidable</span><span class="w"> </span><span class="no">P</span><span class="w">
  </span><span class="o">}.</span><span class="w">
</span></code></pre></div></div>

<h3 id="monad">Monad</h3>

<blockquote>
  <p>In Haskell, one place typeclasses are used very heavily is with the Monad typeclass, especially in conjunction with Haskell’s “do notation” for monadic actions.</p>
</blockquote>

<blockquote>
  <p>Monads are an extremely powerful tool for organizing and streamlining code in a wide range of situations where computations can be thought of as yielding a result along with some kind of “effect.”</p>
</blockquote>

<p>说话很严谨「in a wide range of situations where … “effect”」</p>

<blockquote>
  <p>most older projects simply define their own monads and monadic notations — sometimes typeclass-based, often not — while newer projects use one of several generic libraries for monads. Our current favorite (as of Summer 2017) is the monad typeclasses in Gregory Malecha’s <code class="language-plaintext highlighter-rouge">ext-lib</code> package:</p>
</blockquote>

<p><a href="https://github.com/coq-ext-lib/coq-ext-lib/blob/v8.5/theories/Structures/Monad.v">https://github.com/coq-ext-lib/coq-ext-lib/blob/v8.5/theories/Structures/Monad.v</a></p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Require</span><span class="w"> </span><span class="k">Export</span><span class="w"> </span><span class="nn">ExtLib</span><span class="p">.</span><span class="nn">Structures</span><span class="p">.</span><span class="no">Monads</span><span class="pi">.</span><span class="w">
</span><span class="k">Export</span><span class="w"> </span><span class="no">MonadNotation</span><span class="pi">.</span><span class="w">
</span><span class="no">Open</span><span class="w"> </span><span class="no">Scope</span><span class="w"> </span><span class="no">monad_scope</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Class</span><span class="w"> </span><span class="no">Monad</span><span class="w"> </span><span class="o">(</span><span class="no">M</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w"> 
  </span><span class="no">ret</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="w"> </span><span class="o">{</span><span class="no">T</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">},</span><span class="w"> </span><span class="no">T</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">M</span><span class="w"> </span><span class="no">T</span><span class="w"> </span><span class="p">;</span><span class="w">
  </span><span class="no">bind</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="w"> </span><span class="o">{</span><span class="no">T</span><span class="w"> </span><span class="no">U</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">},</span><span class="w"> </span><span class="no">M</span><span class="w"> </span><span class="no">T</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="o">(</span><span class="no">T</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">M</span><span class="w"> </span><span class="no">U</span><span class="o">)</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">M</span><span class="w"> </span><span class="no">U</span><span class="w">
</span><span class="o">}.</span><span class="w">

</span><span class="k">Instance</span><span class="w"> </span><span class="no">optionMonad</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">Monad</span><span class="w"> </span><span class="no">option</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="w">
  </span><span class="no">ret</span><span class="w"> </span><span class="no">T</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">Some</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="p">;</span><span class="w">
  </span><span class="no">bind</span><span class="w"> </span><span class="no">T</span><span class="w"> </span><span class="no">U</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
    </span><span class="kr">match</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="kp">with</span><span class="w">
      </span><span class="no">None</span><span class="w"> </span><span class="p">⇒</span><span class="w"> </span><span class="no">None</span><span class="w">
    </span><span class="o">|</span><span class="w"> </span><span class="no">Some</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="p">⇒</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="no">x</span><span class="w">
    </span><span class="kr">end</span><span class="w">
</span><span class="o">}.</span><span class="w">
</span></code></pre></div></div>

<p>Compare with Haskell:</p>

<div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">class</span> <span class="kt">Applicative</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="n">m</span> <span class="o">::</span> <span class="o">*</span> <span class="o">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">return</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
  <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="o">::</span> <span class="n">m</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
  
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">Maybe</span> <span class="kr">where</span>
  <span class="n">return</span> <span class="o">=</span> <span class="kt">Just</span>
  <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span>  <span class="o">=</span> <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span>
    <span class="kt">Nothing</span>  <span class="o">&gt;&gt;=</span> <span class="kr">_</span> <span class="o">=</span> <span class="kt">Nothing</span>
    <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span>
</code></pre></div></div>

<p>After mimic <code class="language-plaintext highlighter-rouge">do</code> notation: (as PLF-11)</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">sum3</span><span class="w"> </span><span class="o">(</span><span class="no">l</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">nat</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">option</span><span class="w"> </span><span class="no">nat</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="no">x0</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="no">nth_opt</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="p">;;</span><span class="w">
  </span><span class="no">x1</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="no">nth_opt</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="p">;;</span><span class="w">
  </span><span class="no">x2</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="no">nth_opt</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="p">;;</span><span class="w">
  </span><span class="no">ret</span><span class="w"> </span><span class="o">(</span><span class="no">x0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">x1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">x2</span><span class="o">).</span><span class="w">
</span></code></pre></div></div>

<h2 id="controlling-instantiation">Controlling Instantiation</h2>

<h3 id="defaulting">“Defaulting”</h3>

<p>Would better explicitly typed. searching can be stupid</p>

<h3 id="manipulating-the-hint-database">Manipulating the Hint Database</h3>

<blockquote>
  <p>One of the ways in which Coq’s typeclasses differ most from Haskell’s is the lack, in Coq, of an automatic check for “overlapping instances.”</p>
</blockquote>

<p>在 Haskell 中一大 use case 是可以做类似 C++ 的 partial specification（偏特化）</p>

<ul>
  <li>Check out <a href="https://kseo.github.io/posts/2017-02-05-avoid-overlapping-instances-with-closed-type-families.html">this</a> on the pros and cons of overlapping instances in Haskell</li>
  <li>Check out [this] (https://www.ibm.com/developerworks/community/blogs/12bb75c9-dfec-42f5-8b55-b669cc56ad76/entry/c__e6_a8_a1_e6_9d_bf__e7_a9_b6_e7_ab_9f_e4_bb_80_e4_b9_88_e6_98_af_e7_89_b9_e5_8c_96?lang=en) on template partial specification in C++</li>
</ul>

<blockquote>
  <p>That is, it is completely legal to define a given type to be an instance of a given class in two different ways.
When this happens, it is unpredictable which instance will be found first by the instance search process;</p>
</blockquote>

<p>Workarounds in Coq when this happen:</p>
<ol>
  <li>removing instances from hint database</li>
  <li>priorities</li>
</ol>

<h2 id="debugging">Debugging</h2>

<p>TBD.</p>

<ul>
  <li>Instantiation Failures</li>
  <li>Nontermination</li>
</ul>

<h2 id="alternative-structuring-mechanisms">Alternative Structuring Mechanisms</h2>

<p><em>large-scale structuring mechanisms</em></p>

<blockquote>
  <p>Typeclasses are just one of several mechanisms that can be used in Coq for structuring large developments. Others include:</p>

  <ul>
    <li>canonical structures</li>
    <li>bare dependent records</li>
    <li>modules and functors</li>
  </ul>
</blockquote>

<p>Module and functors is very familiar!</p>

<h2 id="further-reading">Further Reading</h2>

<p>On the origins of typeclasses in Haskell:</p>

<ul>
  <li>How to make ad-hoc polymorphism less ad hoc Philip Wadler and Stephen Blott. 16’th Symposium on Principles of Programming Languages, ACM Press, Austin, Texas, January 1989.
<a href="http://homepages.inf.ed.ac.uk/wadler/topics/type-classes.html">http://homepages.inf.ed.ac.uk/wadler/topics/type-classes.html</a></li>
</ul>

<p>The original paper on typeclasses In Coq:</p>

<ul>
  <li>Matthieu Sozeau and Nicolas Oury. First-Class Type Classes. TPHOLs 2008.
<a href="https://link.springer.com/chapter/10.1007%2F978-3-540-71067-7_23">https://link.springer.com/chapter/10.1007%2F978-3-540-71067-7_23</a></li>
</ul>



                <hr style="visibility: hidden;">
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2019/08/03/CSS-transition-%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC/" data-toggle="tooltip" data-placement="top" title="CSS transition 的默认值">
                        Previous<br>
                        <span>CSS transition 的默认值</span>
                        </a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2019/09/13/peter-john-landin/" data-toggle="tooltip" data-placement="top" title="Peter John Landin">
                        Next<br>
                        <span>Peter John Landin</span>
                        </a>
                    </li>
                    
                </ul>
                <hr style="visibility: hidden;">

                

                
            </div>  

    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                



                <!-- Friends Blog -->
                
            </div>
        </div>
    </div>
</article>

<!-- add support for mathjax by voleking-->









<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'right',
          // icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>

 <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- SNS Link -->
                


<ul class="list-inline text-center">


  
  <li>
    <a href="/feed.xml">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
  <li>
    <a href="https://twitter.com/liuwayong">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
  
  
  
  <li>
    <a target="_blank" href="https://github.com/wayou">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-github fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
</ul>

                <p class="copyright text-muted">
                    Copyright &copy; 牛さんの部落格 2020
                    <br>
                    Powered by <a href="http://huangxuan.me">Hux Blog</a> |
                    <iframe style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0" width="100px"
                        height="20px"
                        src="https://ghbtns.com/github-btn.html?user=huxpro&repo=huxpro.github.io&type=star&count=true">
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<!-- Currently, only navbar scroll-down effect at desktop still depends on this -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>

<!-- Simple Jekyll Search -->
<script src="/js/simple-jekyll-search.min.js"></script>

<!-- Service Worker -->

<script src="/js/snackbar.js "></script>
<script src="/js/sw-registration.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
        var d = document, t = 'script',
            o = d.createElement(t),
            s = d.getElementsByTagName(t)[0];
        o.src = u;
        if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
        s.parentNode.insertBefore(o, s);
    }
</script>

<!--
     Because of the native support for backtick-style fenced code blocks
     right within the Markdown is landed in Github Pages,
     From V1.6, There is no need for Highlight.js,
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/
     - https://github.com/jneen/rouge/wiki/list-of-supported-languages-and-lexers
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->







<!--fastClick.js -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function () {
        var $nav = document.querySelector("nav");
        if ($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->



<!-- Baidu Tongji -->



<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog(selector) {

        // interop with multilangual 
        if ('' == 'true') {
            _containerSelector = 'div.post-container.active'
        } else {
            _containerSelector = 'div.post-container'
        }

        // init
        var P = $(_containerSelector), a, n, t, l, i, c;
        a = P.find('h1,h2,h3,h4,h5,h6');

        // clean
        $(selector).html('')

        // appending
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#" + $(this).prop('id');
            t = $(this).text();
            c = $('<a href="' + i + '" rel="nofollow">' + t + '</a>');
            l = $('<li class="' + n + '_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function (e) {
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>



<!-- Multi-Lingual -->


<!-- Simple Jekyll Search -->
<script>
    // https://stackoverflow.com/questions/1912501/unescape-html-entities-in-javascript
    function htmlDecode(input) {
        var e = document.createElement('textarea');
        e.innerHTML = input;
        // handle case of empty input
        return e.childNodes.length === 0 ? "" : e.childNodes[0].nodeValue;
    }

    SimpleJekyllSearch({
        searchInput: document.getElementById('search-input'),
        resultsContainer: document.getElementById('search-results'),
        json: '/search.json',
        searchResultTemplate: '<div class="post-preview item"><a href="{url}"><h2 class="post-title">{title}</h2><h3 class="post-subtitle">{subtitle}</h3><hr></a></div>',
        noResultsText: 'No results',
        limit: 50,
        fuzzy: false,
        // a hack to get escaped subtitle unescaped. for some reason, 
        // post.subtitle w/o escape filter nuke entire search.
        templateMiddleware: function (prop, value, template) {
            if (prop === 'subtitle' || prop === 'title') {
                if (value.indexOf("code")) {
                    return htmlDecode(value);
                } else {
                    return value;
                }
            }
        }
    });

    $(document).ready(function () {
        var $searchPage = $('.search-page');
        var $searchOpen = $('.search-icon');
        var $searchClose = $('.search-icon-close');
        var $searchInput = $('#search-input');
        var $body = $('body');

        $searchOpen.on('click', function (e) {
            e.preventDefault();
            $searchPage.toggleClass('search-active');
            var prevClasses = $body.attr('class') || '';
            setTimeout(function () {
                $body.addClass('no-scroll');
            }, 400)

            if ($searchPage.hasClass('search-active')) {
                $searchClose.on('click', function (e) {
                    e.preventDefault();
                    $searchPage.removeClass('search-active');
                    $body.attr('class', prevClasses);  // from closure 
                });
                $searchInput.focus();
            }
        });
    });
</script>
  </body>
</html>
