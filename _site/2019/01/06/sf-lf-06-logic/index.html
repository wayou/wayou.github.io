<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <meta name="description" content="notes about the coding life">
    <meta name="keywords"  content="牛哇勇, 博客, 互联网, Web, JavaScript, 前端, 设计">
    <meta name="theme-color" content="#000000">
    
    <!-- Open Graph -->
    <meta property="og:title" content="「SF-LC」6 Logic - 牛さんの部落格|刘哇勇的部落格">
    
    <meta property="og:type" content="article">
    <meta property="og:description" content="We have seen…
">
    
    <meta property="article:published_time" content="2019-01-06T00:00:00Z">
    
    
    <meta property="article:author" content="Hux">
    
    
    <meta property="article:tag" content="LF (逻辑基础)">
    
    <meta property="article:tag" content="SF (软件基础)">
    
    <meta property="article:tag" content="Coq">
    
    <meta property="article:tag" content="笔记">
    
    
    <meta property="og:image" content="http://0.0.0.0:4000">
    <meta property="og:url" content="http://0.0.0.0:4000/2019/01/06/sf-lf-06-logic/">
    <meta property="og:site_name" content="牛さんの部落格|刘哇勇的部落格">
    
    <title>「SF-LC」6 Logic - 牛さんの部落格|刘哇勇的部落格</title>

    <!-- Web App Manifest -->
    <link rel="manifest" href="/pwa/manifest.json">

    <!-- Favicon -->
    <link rel="shortcut icon" href="/img/favicon.ico">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="http://0.0.0.0:4000/2019/01/06/sf-lf-06-logic/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


  <!-- hack iOS CSS :active style -->
  <body ontouchstart="">
    <!-- Navigation -->

<nav class="navbar navbar-default navbar-custom navbar-fixed-top invert">
    
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">牛さんの部落格</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div id="huxblog_navbar">
                <div class="navbar-collapse">
                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="/">Home</a>
                        </li>
                        
                        
                        
                        
                        <li>
                            <a href="/about/">关于</a>
                        </li>
                        
                        
                        
                        <li>
                            <a href="/archive/">Archive</a>
                        </li>
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <li class="search-icon">
                            <a href="javascript:void(0)">
                                <i class="fa fa-search"></i>
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <script>
        // Drop Bootstarp low-performance Navbar
        // Use customize navbar with high-quality material design animation
        // in high-perf jank-free CSS3 implementation
        var $body = document.body;
        var $toggle = document.querySelector('.navbar-toggle');
        var $navbar = document.querySelector('#huxblog_navbar');
        var $collapse = document.querySelector('.navbar-collapse');

        var __HuxNav__ = {
            close: function () {
                $navbar.className = " ";
                // wait until animation end.
                setTimeout(function () {
                    // prevent frequently toggle
                    if ($navbar.className.indexOf('in') < 0) {
                        $collapse.style.height = "0px"
                    }
                }, 400)
            },
            open: function () {
                $collapse.style.height = "auto"
                $navbar.className += " in";
            }
        }

        // Bind Event
        $toggle.addEventListener('click', function (e) {
            if ($navbar.className.indexOf('in') > 0) {
                __HuxNav__.close()
            } else {
                __HuxNav__.open()
            }
        })

        /**
         * Since Fastclick is used to delegate 'touchstart' globally
         * to hack 300ms delay in iOS by performing a fake 'click',
         * Using 'e.stopPropagation' to stop 'touchstart' event from 
         * $toggle/$collapse will break global delegation.
         * 
         * Instead, we use a 'e.target' filter to prevent handler
         * added to document close HuxNav.  
         *
         * Also, we use 'click' instead of 'touchstart' as compromise
         */
        document.addEventListener('click', function (e) {
            if (e.target == $toggle) return;
            if (e.target.className == 'icon-bar') return;
            __HuxNav__.close();
        })
    </script> <!-- Search -->
<div class="search-page">
  <div class="search-icon-close-container">
    <span class="search-icon-close">
      <i class="fa fa-chevron-down"></i>
    </span>
  </div>
  <div class="search-main container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <form></form>
        <input type="text" id="search-input" placeholder="$ grep...">
        </form>
        <div id="search-results" class="mini-post-list"></div>
      </div>
    </div>
  </div>
</div> <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/home-bg.jpg" width="0" height="0"> -->

<!-- Post Header -->



<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/img/home-bg.jpg');
        background: ;
    }

    
</style>

<header class="intro-header style-text" >

    <div class="header-mask"></div>
    
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/archive/?tag=LF+%28%E9%80%BB%E8%BE%91%E5%9F%BA%E7%A1%80%29" title="LF (逻辑基础)">LF (逻辑基础)</a>
                        
                        <a class="tag" href="/archive/?tag=SF+%28%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80%29" title="SF (软件基础)">SF (软件基础)</a>
                        
                        <a class="tag" href="/archive/?tag=Coq" title="Coq">Coq</a>
                        
                        <a class="tag" href="/archive/?tag=%E7%AC%94%E8%AE%B0" title="笔记">笔记</a>
                        
                    </div>
                    <h1>「SF-LC」6 Logic</h1>
                    
                    <h2 class="subheading">Logical Foundations - Logic in Coq</h2>
                    <span class="meta">Posted by Hux on January 6, 2019</span>
                </div>
            </div>
        </div>
    </div>
</header>






<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <!-- Multi-Lingual -->
                

				<p>We have seen…</p>

<ul>
  <li><em>propositions</em>: factual claims
    <ul>
      <li>equality propositions (<code class="language-plaintext highlighter-rouge">e1 = e2</code>)</li>
      <li>implications (<code class="language-plaintext highlighter-rouge">P → Q</code>)</li>
      <li>quantified propositions (<code class="language-plaintext highlighter-rouge">∀ x, P</code>)</li>
    </ul>
  </li>
  <li><em>proofs</em>: ways of presenting <strong>evidence</strong> for the truth of a proposition</li>
</ul>

<h2 id="prop-type"><code class="language-plaintext highlighter-rouge">Prop</code> type</h2>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Check</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="o">.</span><span class="w">  </span><span class="c">(* ===&gt; Prop. A provable prop *)</span><span class="w">
</span><span class="k">Check</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="o">.</span><span class="w">  </span><span class="c">(* ===&gt; Prop. A unprovable prop *)</span><span class="w">
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">Prop</code> is <em>first-class entity</em> we can</p>
<ul>
  <li>name it</li>
  <li><em>parametrized</em>!</li>
</ul>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">is_three</span><span class="w"> </span><span class="o">(</span><span class="no">n</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="no">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="o">.</span><span class="w">

</span><span class="k">Check</span><span class="w"> </span><span class="no">is_three</span><span class="pi">.</span><span class="w"> </span><span class="c">(* ===&gt; nat -&gt; Prop *)</span><span class="w">
</span></code></pre></div></div>

<h3 id="properties">Properties</h3>

<blockquote>
  <p>In Coq, <em>functions that return propositions</em> are said to define <em>properties</em> of their arguments.</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">injective</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="no">B</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">f</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">B</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="p">∀</span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">,</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">y</span><span class="pi">.</span><span class="w">
</span><span class="k">Lemma</span><span class="w"> </span><span class="no">succ_inj</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">injective</span><span class="w"> </span><span class="no">S</span><span class="pi">.</span><span class="w"> </span><span class="c">(* can be read off as "injectivity is a property of S" *)</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w"> 
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="kp">injection</span><span class="w"> </span><span class="no">H</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="no">H1</span><span class="pi">.</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">H1</span><span class="pi">.</span><span class="w"> </span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>The equality operator <code class="language-plaintext highlighter-rouge">=</code> is also a function that returns a <code class="language-plaintext highlighter-rouge">Prop</code>. (property: <em>equality</em>)</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Check</span><span class="w"> </span><span class="o">@</span><span class="no">eq</span><span class="pi">.</span><span class="w"> </span><span class="c">(* ===&gt; forall A : Type, A -&gt; A -&gt; Prop *)</span><span class="w">
</span></code></pre></div></div>

<p>Theroems are types, and proofs are existentials.</p>

<h2 id="slide-qa---1">Slide Q&amp;A - 1.</h2>

<ol>
  <li><code class="language-plaintext highlighter-rouge">Prop</code></li>
  <li><code class="language-plaintext highlighter-rouge">Prop</code></li>
  <li><code class="language-plaintext highlighter-rouge">Prop</code></li>
  <li>Not typeable</li>
  <li><code class="language-plaintext highlighter-rouge">nat -&gt; nat</code></li>
  <li><code class="language-plaintext highlighter-rouge">nat -&gt; Prop</code></li>
  <li>(3)</li>
</ol>

<p>think that Big Lambda (the type abstraction) works at type level, accepts type var, substitute and reture a type.
<code class="language-plaintext highlighter-rouge">forall</code> in Coq is same (the concrete syntax) and only typecheck with <code class="language-plaintext highlighter-rouge">Type</code> or its subtype <code class="language-plaintext highlighter-rouge">Set</code> &amp; <code class="language-plaintext highlighter-rouge">Prop</code>.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Check</span><span class="w"> </span><span class="o">(</span><span class="p">∀</span><span class="no">n</span><span class="p">:</span><span class="no">nat</span><span class="o">,</span><span class="w"> </span><span class="no">S</span><span class="w"> </span><span class="o">(</span><span class="no">pred</span><span class="w"> </span><span class="no">n</span><span class="o">)).</span><span class="w">  </span><span class="c">(* not typeable *)</span><span class="w">

</span><span class="k">Definition</span><span class="w"> </span><span class="no">foo</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="o">(</span><span class="kr">forall</span><span class="w"> </span><span class="no">n</span><span class="p">:</span><span class="no">nat</span><span class="o">,</span><span class="w"> </span><span class="no">bool</span><span class="o">)</span><span class="w"> </span><span class="c">(* foo: nat -&gt; bool *)</span><span class="w">
  </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="kr">fun</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">true</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<h2 id="logical-connectives">Logical Connectives</h2>

<blockquote>
  <p>noticed that connectives symbols are “unicodize” in book and spacemacs.</p>
</blockquote>

<h3 id="conjuction-logical-and">Conjuction (logical and)</h3>

<p><code class="language-plaintext highlighter-rouge">and</code> is just binary <code class="language-plaintext highlighter-rouge">Prop -&gt; Prop -&gt; Prop</code> and associative.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Print</span><span class="w"> </span><span class="s2">"/\".
Inductive and (A B : Prop) : Prop :=  conj : A -&gt; B -&gt; A /\ B
Check and. (* ===&gt; and : Prop -&gt; Prop -&gt; Prop *)
</span></code></pre></div></div>

<h4 id="and-introduction">and introduction</h4>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Lemma</span><span class="w"> </span><span class="no">and_intro</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="o">,</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="o">/\</span><span class="w"> </span><span class="no">B</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="no">HA</span><span class="w"> </span><span class="no">HB</span><span class="pi">.</span><span class="w"> </span><span class="kp">split</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">HA</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">HB</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>
<blockquote>
  <p>To prove a conjunction,</p>
  <ul>
    <li>use the <code class="language-plaintext highlighter-rouge">split</code> tactic. It will generate two subgoals,</li>
    <li>or use <code class="language-plaintext highlighter-rouge">apply and_intro.</code>, which match the conclusion and give its two premises as your subgoals.</li>
  </ul>
</blockquote>

<h4 id="and-elimination">and elimination</h4>

<p>if we already have a proof of <code class="language-plaintext highlighter-rouge">and</code>, <code class="language-plaintext highlighter-rouge">destruct</code> can give us both.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Lemma</span><span class="w"> </span><span class="no">and_example2'</span><span class="w"> </span><span class="p">:</span><span class="w">
  </span><span class="p">∀</span><span class="no">n</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">,</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">∧</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="o">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="o">[</span><span class="no">Hn</span><span class="w"> </span><span class="no">Hm</span><span class="o">].</span><span class="w"> </span><span class="c">(* = intro H. destruct H. *)</span><span class="w">
  </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">Hn</span><span class="pi">.</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">Hm</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w"> </span><span class="k">Qed</span><span class="pi">.</span><span class="w">  </span><span class="c">(* you could use only one *)</span><span class="w">
</span></code></pre></div></div>

<p>Instead of packing into conjunction <code class="language-plaintext highlighter-rouge">∀n m : nat, n = 0 ∧ m = 0 → n + m = 0.</code>
why not two separate premises?      <code class="language-plaintext highlighter-rouge">∀n m : nat, n = 0 -&gt; m = 0 → n + m = 0.</code> 
Both are fine in this case but conjunction are useful as intermediate step etc.</p>

<blockquote>
  <p>Coq Intensive Q: why <code class="language-plaintext highlighter-rouge">destruct</code> can work on <code class="language-plaintext highlighter-rouge">and</code>? is <code class="language-plaintext highlighter-rouge">and</code> inductively defined?
A: Yes.</p>
</blockquote>

<h3 id="disjunction-locial-or">Disjunction (locial or)</h3>

<h4 id="or-elimination">or elimination</h4>

<p>We need do case analysis (either <code class="language-plaintext highlighter-rouge">P</code> or <code class="language-plaintext highlighter-rouge">Q</code> should be able to prove the theroem separately!)</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Lemma</span><span class="w"> </span><span class="no">or_example</span><span class="w"> </span><span class="p">:</span><span class="w">
  </span><span class="kr">forall</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">,</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">\/</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="o">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="c">(* This pattern implicitly does case analysis on [n = 0 \/ m = 0] *)</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="no">m</span><span class="w"> </span><span class="o">[</span><span class="no">Hn</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="no">Hm</span><span class="o">].</span><span class="w"> </span><span class="c">(* = intro H. destruct H. *)</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="c">(* Here, [n = 0] *)</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">Hn</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="c">(* Here, [m = 0] *)</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">Hm</span><span class="pi">.</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="no">mult_n_O</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<h4 id="or-introduction">or introduction</h4>

<p>When trying to establish (intro into conclusion) an <code class="language-plaintext highlighter-rouge">or</code>, using <code class="language-plaintext highlighter-rouge">left</code> or <code class="language-plaintext highlighter-rouge">right</code> to pick one side to prove is sufficient.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Lemma</span><span class="w"> </span><span class="no">or_intro</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="o">,</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="o">\/</span><span class="w"> </span><span class="no">B</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="no">HA</span><span class="pi">.</span><span class="w">
  </span><span class="no">left</span><span class="pi">.</span><span class="w">  </span><span class="c">(* tactics *)</span><span class="w">
  </span><span class="kp">apply</span><span class="w"> </span><span class="no">HA</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<h3 id="falsehood-and-negation">Falsehood and negation</h3>

<h4 id="false">False?</h4>

<p>Recall the <em>princple of explosion</em>: it asserts that, if we assume a <em>contradiction</em>, then any other proposition can be derived.
we could define <code class="language-plaintext highlighter-rouge">¬ P</code> (“not P”) as <code class="language-plaintext highlighter-rouge">∀ Q, P → Q.</code>.</p>

<blockquote>
  <p>Coq actually makes a slightly different (but equivalent) choice, defining <code class="language-plaintext highlighter-rouge">¬ P as P → False</code>, where <code class="language-plaintext highlighter-rouge">False</code> is a specific <em>contradictory proposition</em> defined in the standard library.</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">not</span><span class="w"> </span><span class="o">(</span><span class="no">P</span><span class="p">:</span><span class="kr">Prop</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">False</span><span class="pi">.</span><span class="w">
</span><span class="k">Notation</span><span class="w"> </span><span class="s2">"¬x"</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="no">not</span><span class="w"> </span><span class="no">x</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">type_scope</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>Prove the <em>princple of explosion</em>:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">ex_falso_quodlibet</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="o">(</span><span class="no">P</span><span class="p">:</span><span class="kr">Prop</span><span class="o">),</span><span class="w">
  </span><span class="no">False</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">P</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="no">contra</span><span class="pi">.</span><span class="w">
  </span><span class="kp">destruct</span><span class="w"> </span><span class="no">contra</span><span class="pi">.</span><span class="w">  </span><span class="k">Qed</span><span class="pi">.</span><span class="w">  </span><span class="c">(* 0 cases to prove since ⊥ is not provable. [inversion] also works *)</span><span class="w">
</span></code></pre></div></div>

<h4 id="inequality">Inequality</h4>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Notation</span><span class="w"> </span><span class="s2">"x &lt;&gt; y"</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">(~(</span><span class="no">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">y</span><span class="o">)).</span><span class="w">
</span></code></pre></div></div>

<p>Same as SML and OCaml (for structural equality, OCaml uses <code class="language-plaintext highlighter-rouge">!=</code> for physical equality.)</p>

<h4 id="proving-of-negation-or-how-to-prove-p">Proving of negation (or how to prove <code class="language-plaintext highlighter-rouge">¬P</code>)</h4>

<p>thinking about as <code class="language-plaintext highlighter-rouge">unfold not</code>, i.e. <code class="language-plaintext highlighter-rouge">P -&gt; False</code>.
so you have an assumptions <code class="language-plaintext highlighter-rouge">P</code> that could be <code class="language-plaintext highlighter-rouge">intros HP.</code> and the residual goal would be simply <code class="language-plaintext highlighter-rouge">False</code>. 
which is usually proved by some kind of contradiction in hypotheses with tactics <code class="language-plaintext highlighter-rouge">discriminate.</code> or <code class="language-plaintext highlighter-rouge">contradiction.</code></p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">contradiction_implies_anything</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="no">Q</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="o">,</span><span class="w">
  </span><span class="o">(</span><span class="no">P</span><span class="w"> </span><span class="o">/\</span><span class="w"> </span><span class="nv">~P</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">Q</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="no">Q</span><span class="w"> </span><span class="o">[</span><span class="no">HP</span><span class="w"> </span><span class="no">HNA</span><span class="o">].</span><span class="w">                 </span><span class="c">(* we could [contradiction.] to end the proof here`*)</span><span class="w">
  </span><span class="kp">unfold</span><span class="w"> </span><span class="no">not</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">HNA</span><span class="pi">.</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">HNA</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="no">HP</span><span class="pi">.</span><span class="w">  </span><span class="c">(* HP : False, HNA : P -&gt; False  ⊢  HP: False  *)</span><span class="w">
  </span><span class="kp">destruct</span><span class="w"> </span><span class="no">HP</span><span class="pi">.</span><span class="w">  </span><span class="k">Qed</span><span class="pi">.</span><span class="w">                   </span><span class="c">(* destruct False.  *)</span><span class="w">
</span></code></pre></div></div>

<h4 id="tactic-exfalso">Tactic <code class="language-plaintext highlighter-rouge">exfalso.</code></h4>

<blockquote>
  <p>If you are trying to prove a goal that is nonsensical (e.g., the goal state is <code class="language-plaintext highlighter-rouge">false = true</code>), apply <code class="language-plaintext highlighter-rouge">ex_falso_quodlibet</code> to change the goal to <code class="language-plaintext highlighter-rouge">False</code>. This makes it easier to use assumptions of the form <code class="language-plaintext highlighter-rouge">¬P</code> that may be available in the context — in particular, assumptions of the form <code class="language-plaintext highlighter-rouge">x≠y</code>.</p>
</blockquote>

<blockquote>
  <p>Since reasoning with <code class="language-plaintext highlighter-rouge">ex_falso_quodlibet</code> is quite common, Coq provides a built-in tactic, <code class="language-plaintext highlighter-rouge">exfalso</code>, for applying it.</p>
</blockquote>

<h2 id="slide-qa---2">Slide Q&amp;A - 2</h2>

<blockquote>
  <p>?<code class="language-plaintext highlighter-rouge">unfold</code> is implicit</p>
</blockquote>

<ol>
  <li>only <code class="language-plaintext highlighter-rouge">destruct</code> (if we consider <code class="language-plaintext highlighter-rouge">intros</code> destruct is also <code class="language-plaintext highlighter-rouge">destruct</code>.), ?<code class="language-plaintext highlighter-rouge">unfold</code></li>
  <li>none (?<code class="language-plaintext highlighter-rouge">unfold</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">left.</code></li>
  <li><code class="language-plaintext highlighter-rouge">destruct</code>, <code class="language-plaintext highlighter-rouge">unfold</code>, <code class="language-plaintext highlighter-rouge">left</code> and <code class="language-plaintext highlighter-rouge">right</code></li>
  <li><code class="language-plaintext highlighter-rouge">discrinminate</code> (or <code class="language-plaintext highlighter-rouge">inversion</code>)</li>
</ol>

<h3 id="truth">Truth</h3>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Lemma</span><span class="w"> </span><span class="no">True_is_true</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">True</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">I</span><span class="pi">.</span><span class="w"> </span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">I : True</code> is a predefined Prop…</p>

<h3 id="logical-equivalence">Logical Equivalence</h3>

<p><em>if and only if</em> is just the conjunction of two implications. (so we need <code class="language-plaintext highlighter-rouge">split</code> to get 2 subgoals)</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Definition</span><span class="w"> </span><span class="no">iff</span><span class="w"> </span><span class="o">(</span><span class="no">P</span><span class="w"> </span><span class="no">Q</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="no">P</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">Q</span><span class="o">)</span><span class="w"> </span><span class="p">∧</span><span class="w"> </span><span class="o">(</span><span class="no">Q</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">P</span><span class="o">).</span><span class="w">
</span><span class="k">Notation</span><span class="w"> </span><span class="s2">"P ↔ Q"</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="no">iff</span><span class="w"> </span><span class="no">P</span><span class="w"> </span><span class="no">Q</span><span class="o">)</span><span class="w">
                    </span><span class="o">(</span><span class="kp">at</span><span class="w"> </span><span class="no">level</span><span class="w"> </span><span class="mi">95</span><span class="o">,</span><span class="w"> </span><span class="no">no</span><span class="w"> </span><span class="no">associativity</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">type_scope</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">rewrite</code> and <code class="language-plaintext highlighter-rouge">reflexivity</code> can be used with iff statements, not just equalities.</p>
</blockquote>

<h3 id="existential-quantification">Existential Quantification</h3>

<p>To prove a statement of the form <code class="language-plaintext highlighter-rouge">∃x, P</code>, we must show that <code class="language-plaintext highlighter-rouge">P</code> holds for some specific choice of value for <code class="language-plaintext highlighter-rouge">x</code>, 
known as the <strong>witness</strong> of the existential.</p>

<p>So we explicitly tell Coq which witness <code class="language-plaintext highlighter-rouge">t</code> we have in mind by invoking <code class="language-plaintext highlighter-rouge">exists t</code>.
then all occurences of that “type variable” would be replaced.</p>

<h4 id="intro">Intro</h4>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Lemma</span><span class="w"> </span><span class="no">four_is_even</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kp">exists</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">n</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">exists</span><span class="w"> </span><span class="mi">2</span><span class="o">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<h4 id="elim">Elim</h4>

<p>Below is an interesting question…by intros and destruct we can have equation <code class="language-plaintext highlighter-rouge">n = 4 + m</code> in hypotheses.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">exists_example_2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">n</span><span class="o">,</span><span class="w">
  </span><span class="o">(</span><span class="kp">exists</span><span class="w"> </span><span class="no">m</span><span class="o">,</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">m</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
  </span><span class="o">(</span><span class="kp">exists</span><span class="w"> </span><span class="no">o</span><span class="o">,</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">o</span><span class="o">).</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">[</span><span class="no">m</span><span class="w"> </span><span class="no">Hm</span><span class="o">].</span><span class="w"> </span><span class="c">(* note implicit [destruct] here *)</span><span class="w">
  </span><span class="kp">exists</span><span class="w"> </span><span class="o">(</span><span class="mi">2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">m</span><span class="o">).</span><span class="w">
  </span><span class="kp">apply</span><span class="w"> </span><span class="no">Hm</span><span class="pi">.</span><span class="w">  </span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<h2 id="programming-with-propositions">Programming with Propositions</h2>

<p>Considering writing a common recursive <code class="language-plaintext highlighter-rouge">is_in</code> for polymorphic lists. 
(Though we dont have a polymorphic <code class="language-plaintext highlighter-rouge">=?</code> (<code class="language-plaintext highlighter-rouge">eqb</code>) defined yet)</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Fixpoint</span><span class="w"> </span><span class="no">is_in</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">l</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">bool</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">match</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="kp">with</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="o">[]</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">false</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">x'</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="no">l'</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="kr">if</span><span class="w"> </span><span class="o">(</span><span class="no">x'</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="no">x</span><span class="o">)</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="no">true</span><span class="w"> </span><span class="kr">else</span><span class="w"> </span><span class="no">is_in</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">l'</span><span class="w">
  </span><span class="kr">end</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>Similarly, we can write this function but with disjunction and return a <code class="language-plaintext highlighter-rouge">Prop</code>!
<em>so we can write function to generate/create statements/propositions!</em> (thx for the idea Prop is first-class)</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Fixpoint</span><span class="w"> </span><span class="no">In</span><span class="w"> </span><span class="o">{</span><span class="no">A</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">l</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Prop</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">match</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="kp">with</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="o">[]</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">False</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">x'</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="no">l'</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">x'</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="p">∨</span><span class="w"> </span><span class="no">In</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">l'</span><span class="w">
  </span><span class="kr">end</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>The whole thing I understood as a <em>type operator</em> (function in type level) and it’s <em>recursive</em>!</p>

<p>Coq dare to do that becuz its <em>total</em>, which is guarded by its <em>termination checker</em>.
un-total PL, if having this, would make its type system <em>Turing Complete</em> (thus having <em>Halting Problem</em>).
(Recursive Type like ADT/GADT in ML/Haskell is a limited form of recursion allowing no arbitray recursion.)</p>

<h3 id="in_map">In_map</h3>

<p>I took this one since it’s like a formal version of <em>Property-based Tests</em>!.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Lemma</span><span class="w"> </span><span class="no">In_map</span><span class="w"> </span><span class="p">:</span><span class="w">
  </span><span class="kr">forall</span><span class="w"> </span><span class="o">(</span><span class="no">A</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">f</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">B</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">l</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">A</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">A</span><span class="o">),</span><span class="w">
    </span><span class="no">In</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">
    </span><span class="no">In</span><span class="w"> </span><span class="o">(</span><span class="no">f</span><span class="w"> </span><span class="no">x</span><span class="o">)</span><span class="w"> </span><span class="o">(</span><span class="no">map</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="no">l</span><span class="o">).</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">A</span><span class="w"> </span><span class="no">B</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="no">x</span><span class="pi">.</span><span class="w">
  </span><span class="kp">induction</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="kr">as</span><span class="w"> </span><span class="o">[|</span><span class="no">x'</span><span class="w"> </span><span class="no">l'</span><span class="w"> </span><span class="no">IHl'</span><span class="o">].</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="c">(* l = nil, contradiction *)</span><span class="w">
    </span><span class="kp">simpl</span><span class="pi">.</span><span class="w"> </span><span class="kp">intros</span><span class="w"> </span><span class="o">[].</span><span class="w">
  </span><span class="o">-</span><span class="w"> </span><span class="c">(* l = x' :: l' *)</span><span class="w">
    </span><span class="kp">simpl</span><span class="pi">.</span><span class="w"> </span><span class="kp">intros</span><span class="w"> </span><span class="o">[</span><span class="no">H</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="no">H</span><span class="o">].</span><span class="w">           </span><span class="c">(* evaluating [In] gives us 2 cases:  *)</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w"> </span><span class="no">left</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w">  </span><span class="c">(* in head of l *)</span><span class="w">
    </span><span class="o">+</span><span class="w"> </span><span class="no">right</span><span class="pi">.</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">IHl'</span><span class="pi">.</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">H</span><span class="pi">.</span><span class="w">    </span><span class="c">(* in tail of l*)</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<blockquote>
  <p>Q &amp; A:</p>
  <ol>
    <li><code class="language-plaintext highlighter-rouge">eq</code> is just another inductively defined and doesn’t have any computational content. (satisfication)</li>
    <li>Why use <code class="language-plaintext highlighter-rouge">Prop</code> instead of <code class="language-plaintext highlighter-rouge">bool</code>? See <em>reflection</em> below.</li>
  </ol>
</blockquote>

<h3 id="drawbacks">Drawbacks</h3>

<blockquote>
  <p>In particular, it is subject to Coq’s usual restrictions regarding the definition of recursive functions, 
e.g., the requirement that they be “obviously terminating.”</p>
</blockquote>

<blockquote>
  <p>In the next chapter, we will see how to define propositions <em>inductively</em>, 
a different technique with its own set of strengths and limitations.</p>
</blockquote>

<h2 id="applying-theorems-to-arguments">Applying Theorems to Arguments.</h2>

<h3 id="check-some_theorem-print-the-statement"><code class="language-plaintext highlighter-rouge">Check some_theorem</code> print the statement!</h3>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Check</span><span class="w"> </span><span class="no">plus_comm</span><span class="pi">.</span><span class="w">
</span><span class="c">(* ===&gt; forall n m : nat, n + m = m + n *)</span><span class="w">
</span></code></pre></div></div>

<blockquote>
  <p>Coq prints the <em>statement</em> of the <code class="language-plaintext highlighter-rouge">plus_comm</code> theorem in the same way that it prints the <em>type</em> of any term that we ask it to Check. Why?</p>
</blockquote>

<p>Hmm…I just noticed that!!
But I should notice because <strong>Propositions are Types! (and terms are proof)</strong></p>

<h3 id="proof-object">Proof Object</h3>

<blockquote>
  <p><em>proofs</em> as first-class objects.</p>
</blockquote>

<p>After <code class="language-plaintext highlighter-rouge">Qed.</code>, Coq defined they as <em>Proof Object</em> and the <em>type of this obj</em> is the statement of the theorem.</p>

<blockquote>
  <p>Provable: some type is inhabited by some thing (having terms).</p>
</blockquote>

<p>So I guess when we apply theorems, Coq implicitly use the type of the Proof Object. (it’s already type abstraction)
…we will get to there later at ProofObject chapter.</p>

<h3 id="apply-theorem-as-function">Apply theorem as function</h3>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">rewrite</code> select variables greedily by default</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Lemma</span><span class="w"> </span><span class="no">plus_comm3_take3</span><span class="w"> </span><span class="p">:</span><span class="w">
  </span><span class="p">∀</span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="no">z</span><span class="o">,</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">(</span><span class="no">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">z</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="no">z</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">y</span><span class="o">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="no">x</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w">
  </span><span class="kp">intros</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="no">z</span><span class="pi">.</span><span class="w">
  </span><span class="kp">rewrite</span><span class="w"> </span><span class="no">plus_comm</span><span class="pi">.</span><span class="w">
  </span><span class="kp">rewrite</span><span class="w"> </span><span class="o">(</span><span class="no">plus_comm</span><span class="w"> </span><span class="no">y</span><span class="w"> </span><span class="no">z</span><span class="o">).</span><span class="w">     </span><span class="c">(* we can explicitly provide type var! *)</span><span class="w">
  </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w">
</span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">x y z</code> were some type var and <em>instantiated to values</em> by <code class="language-plaintext highlighter-rouge">intros</code>, e.g. <code class="language-plaintext highlighter-rouge">x, y, z:nat</code> 
but we can explicilty pass in to <code class="language-plaintext highlighter-rouge">plus_comm</code>, which is a forall type abstraction! (<code class="language-plaintext highlighter-rouge">Δ n m. (eq (n + m) (m + n))</code>)</p>

<blockquote>
  <p>there must be something there in Proof Object so we can apply <em>values</em> to a <em>type-level function</em></p>
</blockquote>

<h2 id="coq-vs-set-theory">Coq vs. Set Theory</h2>

<p>Coq’s logical core, <em>the Calculus of Inductive Constructions</em>, is a <em>metalanguage for math</em>, but differs from other foundations of math e.g. ZFC Set Theory</p>

<h3 id="functional-extensionality">Functional Extensionality</h3>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">(</span><span class="p">∀</span><span class="no">x</span><span class="o">,</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">g</span><span class="w"> </span><span class="no">x</span><span class="o">)</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">g</span><span class="w">

</span><span class="p">∃</span><span class="no">f</span><span class="w"> </span><span class="no">g</span><span class="o">,</span><span class="w"> </span><span class="o">(</span><span class="p">∀</span><span class="no">x</span><span class="o">,</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">g</span><span class="w"> </span><span class="no">x</span><span class="o">)</span><span class="w"> </span><span class="p">→</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">g</span><span class="w">

</span><span class="p">∃</span><span class="no">f</span><span class="w"> </span><span class="no">g</span><span class="o">,</span><span class="w"> </span><span class="o">(</span><span class="p">∀</span><span class="no">x</span><span class="o">,</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">g</span><span class="w"> </span><span class="no">x</span><span class="o">)</span><span class="w"> </span><span class="p">∧</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="no">g</span><span class="w">    </span><span class="c">(* negation, consistent but not interesting... *)</span><span class="w">
</span></code></pre></div></div>

<blockquote>
  <p>In common math practice, two functions <code class="language-plaintext highlighter-rouge">f</code> and <code class="language-plaintext highlighter-rouge">g</code> are considered equal if they produce the same outputs.
This is known as the principle of <em>functional extensionality</em>.</p>
</blockquote>

<blockquote>
  <p>Informally speaking, an “extensional property” is one that pertains to an object’s observable behavior.
<a href="https://en.wikipedia.org/wiki/Extensionality">https://en.wikipedia.org/wiki/Extensionality</a>
<a href="https://en.wikipedia.org/wiki/Extensional_and_intensional_definitions">https://en.wikipedia.org/wiki/Extensional_and_intensional_definitions</a>?</p>
</blockquote>

<p>This is not built-in Coq, but we can add them as Axioms. 
Why not add everything?</p>
<blockquote>
  <ol>
    <li>One or multiple axioms combined might render <em>inconsistency</em>.</li>
    <li>Code extraction might be problematic</li>
  </ol>
</blockquote>

<blockquote>
  <p>Fortunately, it is known that adding functional extensionality, in particular, is consistent.
<a href="https://en.wikipedia.org/wiki/Consistency">consistency</a>:
   a consistent theory is one that does not contain a contradiction.</p>
</blockquote>

<h3 id="adding-axioms">Adding Axioms</h3>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Axiom</span><span class="w"> </span><span class="no">functional_extensionality</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="o">{</span><span class="no">X</span><span class="w"> </span><span class="no">Y</span><span class="p">:</span><span class="w"> </span><span class="kr">Type</span><span class="o">}</span><span class="w">
                                    </span><span class="o">{</span><span class="no">f</span><span class="w"> </span><span class="no">g</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">Y</span><span class="o">},</span><span class="w">
  </span><span class="o">(</span><span class="kr">forall</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="p">:</span><span class="no">X</span><span class="o">),</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">g</span><span class="w"> </span><span class="no">x</span><span class="o">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="no">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">g</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>It’s like <code class="language-plaintext highlighter-rouge">Admitted.</code> but alerts we’re not going to fill in later.</p>

<h3 id="exercise---proving-reverse-with-app-and-with-cons-are-fn-exensionally-equivalent">Exercise - Proving Reverse with <code class="language-plaintext highlighter-rouge">app</code> and with <code class="language-plaintext highlighter-rouge">cons</code> are fn-exensionally equivalent.</h3>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Fixpoint</span><span class="w"> </span><span class="no">rev_append</span><span class="w"> </span><span class="o">{</span><span class="no">X</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">l1</span><span class="w"> </span><span class="no">l2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">X</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">match</span><span class="w"> </span><span class="no">l1</span><span class="w"> </span><span class="kp">with</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="o">[]</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">l2</span><span class="w">
  </span><span class="o">|</span><span class="w"> </span><span class="no">x</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="no">l1'</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="no">rev_append</span><span class="w"> </span><span class="no">l1'</span><span class="w"> </span><span class="o">(</span><span class="no">x</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="no">l2</span><span class="o">)</span><span class="w">
  </span><span class="kr">end</span><span class="pi">.</span><span class="w">

</span><span class="k">Definition</span><span class="w"> </span><span class="no">tr_rev</span><span class="w"> </span><span class="o">{</span><span class="no">X</span><span class="o">}</span><span class="w"> </span><span class="o">(</span><span class="no">l</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">X</span><span class="o">)</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">list</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="no">rev_append</span><span class="w"> </span><span class="no">l</span><span class="w"> </span><span class="o">[].</span><span class="w">
</span></code></pre></div></div>

<p>BTW, this version is <code class="language-plaintext highlighter-rouge">tail recursive</code> becuz the recursive call is the last operation needs to performed.
(In <code class="language-plaintext highlighter-rouge">rev</code> i.e. <code class="language-plaintext highlighter-rouge">rev t ++ [h]</code>, recursive call is a argument of function <code class="language-plaintext highlighter-rouge">++</code> and we are CBV.)</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Lemma</span><span class="w"> </span><span class="no">tr_rev_correct</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kr">forall</span><span class="w"> </span><span class="no">X</span><span class="o">,</span><span class="w"> </span><span class="o">@</span><span class="no">tr_rev</span><span class="w"> </span><span class="no">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">@</span><span class="no">rev</span><span class="w"> </span><span class="no">X</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<h3 id="propositions-and-booleans">Propositions and Booleans</h3>

<blockquote>
  <p>We’ve seen two different ways of expressing logical claims in Coq:</p>
  <ol>
    <li>with booleans     (of type <code class="language-plaintext highlighter-rouge">bool</code>),  ; computational way</li>
    <li>with propositions (of type <code class="language-plaintext highlighter-rouge">Prop</code>).  ; logical way</li>
  </ol>
</blockquote>

<p>There’re two ways to define 42 is even:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Example</span><span class="w"> </span><span class="no">even_42_bool</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">evenb</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">true</span><span class="pi">.</span><span class="w">
</span><span class="k">Example</span><span class="w"> </span><span class="no">even_42_prop</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∃</span><span class="no">k</span><span class="o">,</span><span class="w"> </span><span class="mi">42</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">double</span><span class="w"> </span><span class="no">k</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p>We wanna show there are <em>interchangable</em>.</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">even_bool_prop</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="no">n</span><span class="o">,</span><span class="w">
  </span><span class="no">evenb</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">true</span><span class="w"> </span><span class="p">↔</span><span class="w"> </span><span class="p">∃</span><span class="no">k</span><span class="o">,</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">double</span><span class="w"> </span><span class="no">k</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<blockquote>
  <p>In view of this theorem, we say that the 
boolean computation <code class="language-plaintext highlighter-rouge">evenb n</code> <em>reflects</em> the truth of the proposition <code class="language-plaintext highlighter-rouge">∃ k, n = double k</code>.</p>
</blockquote>

<p>We can futhur general this to any equations representing as <code class="language-plaintext highlighter-rouge">bool</code> or <code class="language-plaintext highlighter-rouge">Prop</code>:</p>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">Theorem</span><span class="w"> </span><span class="no">eqb_eq</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∀</span><span class="no">n1</span><span class="w"> </span><span class="no">n2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">nat</span><span class="o">,</span><span class="w">
  </span><span class="no">n1</span><span class="w"> </span><span class="o">=?</span><span class="w"> </span><span class="no">n2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">true</span><span class="w"> </span><span class="p">↔</span><span class="w"> </span><span class="no">n1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">n2</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<h4 id="notes-on-computability">Notes on Computability.</h4>

<blockquote>
  <p>However, even they are equivalent from a purely logical perspective, 
they may not be equivalent <code class="language-plaintext highlighter-rouge">operationally</code>.</p>
</blockquote>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Fail</span><span class="w"> </span><span class="k">Definition</span><span class="w"> </span><span class="no">is_even_prime</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w">
  </span><span class="kr">if</span><span class="w"> </span><span class="no">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="kr">then</span><span class="w"> </span><span class="no">true</span><span class="w">
  </span><span class="kr">else</span><span class="w"> </span><span class="no">false</span><span class="pi">.</span><span class="w">

</span><span class="no">Error</span><span class="p">:</span><span class="w"> </span><span class="no">The</span><span class="w"> </span><span class="no">term</span><span class="w"> </span><span class="s2">"n = 2"</span><span class="w"> </span><span class="no">has</span><span class="w"> </span><span class="no">type</span><span class="w"> </span><span class="s2">"Prop"</span><span class="w"> </span><span class="no">which</span><span class="w"> </span><span class="no">is</span><span class="w"> </span><span class="no">not</span><span class="w"> </span><span class="no">a</span><span class="w"> </span><span class="o">(</span><span class="no">co</span><span class="o">-)</span><span class="no">inductive</span><span class="w"> </span><span class="no">type</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">=</code>, or <code class="language-plaintext highlighter-rouge">eq</code>, as any function in Coq, need to be computable and total. And we have no way to tell <em>whether any given proposition is true or false</em>. (…We can only naturally deduce things are inductively defined)</p>

<blockquote>
  <p>As a consequence, Prop in Coq does not have a universal case analysis operation telling whether any given proposition is true or false, since such an operation would allow us to write non-computable functions.</p>
</blockquote>

<blockquote>
  <p>Although general non-computable properties cannot be phrased as boolean computations, it is worth noting that even many computable properties are easier to express using Prop than bool, since recursive function definitions are subject to significant restrictions in Coq.</p>
</blockquote>

<p>E.g. Verifying Regular Expr in next chapter.</p>
<blockquote>
  <p>Doing the same with <code class="language-plaintext highlighter-rouge">bool</code> would amount to writing a <em>full regular expression matcher</em> (so we can execute the regex).</p>
</blockquote>

<h4 id="proof-by-reflection">Proof by Reflection!</h4>

<div class="language-coq highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">(* Logically *)</span><span class="w">
</span><span class="k">Example</span><span class="w"> </span><span class="no">even_1000</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∃</span><span class="no">k</span><span class="o">,</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">double</span><span class="w"> </span><span class="no">k</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w"> </span><span class="p">∃</span><span class="mi">500</span><span class="o">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w"> </span><span class="k">Qed</span><span class="pi">.</span><span class="w">

</span><span class="c">(* Computationally *)</span><span class="w">
</span><span class="k">Example</span><span class="w"> </span><span class="no">even_1000'</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="no">evenb</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">true</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w"> </span><span class="k">Qed</span><span class="pi">.</span><span class="w">

</span><span class="c">(* Prove logical version by reflecting in computational version *)</span><span class="w">
</span><span class="k">Example</span><span class="w"> </span><span class="no">even_1000''</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">∃</span><span class="no">k</span><span class="o">,</span><span class="w"> </span><span class="mi">1000</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="no">double</span><span class="w"> </span><span class="no">k</span><span class="pi">.</span><span class="w">
</span><span class="k">Proof</span><span class="pi">.</span><span class="w"> </span><span class="kp">apply</span><span class="w"> </span><span class="no">even_bool_prop</span><span class="pi">.</span><span class="w"> </span><span class="ne">reflexivity</span><span class="pi">.</span><span class="w"> </span><span class="k">Qed</span><span class="pi">.</span><span class="w">
</span></code></pre></div></div>

<blockquote>
  <p>As an extreme example, the Coq proof of the famous <em>4-color theorem</em> uses reflection to reduce the analysis of hundreds of different cases to a boolean computation.</p>
</blockquote>

<h3 id="classical-vs-constructive-logic">Classical vs. Constructive Logic</h3>

<p>…</p>

<h2 id="future-schedule">Future Schedule</h2>

<blockquote>
  <p>Proof got messier!
Lean on your past PLT experience</p>
</blockquote>

<p>As discussion leader</p>

<ul>
  <li>having many materials now</li>
  <li>selected troublesome and interesting ones</li>
</ul>



                <hr style="visibility: hidden;">
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2019/01/05/sf-lf-05-tactics/" data-toggle="tooltip" data-placement="top" title="「SF-LC」5 Tactics">
                        Previous<br>
                        <span>「SF-LC」5 Tactics</span>
                        </a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2019/01/07/sf-lf-07-indprop/" data-toggle="tooltip" data-placement="top" title="「SF-LC」7 Ind Prop">
                        Next<br>
                        <span>「SF-LC」7 Ind Prop</span>
                        </a>
                    </li>
                    
                </ul>
                <hr style="visibility: hidden;">

                

                
            </div>  

    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                



                <!-- Friends Blog -->
                
            </div>
        </div>
    </div>
</article>

<!-- add support for mathjax by voleking-->









<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'hover',
          placement: 'right',
          // icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>

 <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <!-- SNS Link -->
                


<ul class="list-inline text-center">


  
  <li>
    <a href="/feed.xml">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
  <li>
    <a href="https://twitter.com/liuwayong">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
  
  
  
  <li>
    <a target="_blank" href="https://github.com/wayou">
      <span class="fa-stack fa-lg">
        <i class="fa fa-circle fa-stack-2x"></i>
        <i class="fa fa-github fa-stack-1x fa-inverse"></i>
      </span>
    </a>
  </li>
  
  
</ul>

                <p class="copyright text-muted">
                    Copyright &copy; 牛さんの部落格 2020
                    <br>
                    Powered by <a href="http://huangxuan.me">Hux Blog</a> |
                    <iframe style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0" width="100px"
                        height="20px"
                        src="https://ghbtns.com/github-btn.html?user=huxpro&repo=huxpro.github.io&type=star&count=true">
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<!-- Currently, only navbar scroll-down effect at desktop still depends on this -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>

<!-- Simple Jekyll Search -->
<script src="/js/simple-jekyll-search.min.js"></script>

<!-- Service Worker -->

<script src="/js/snackbar.js "></script>
<script src="/js/sw-registration.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
        var d = document, t = 'script',
            o = d.createElement(t),
            s = d.getElementsByTagName(t)[0];
        o.src = u;
        if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
        s.parentNode.insertBefore(o, s);
    }
</script>

<!--
     Because of the native support for backtick-style fenced code blocks
     right within the Markdown is landed in Github Pages,
     From V1.6, There is no need for Highlight.js,
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/
     - https://github.com/jneen/rouge/wiki/list-of-supported-languages-and-lexers
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->







<!--fastClick.js -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function () {
        var $nav = document.querySelector("nav");
        if ($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->



<!-- Baidu Tongji -->



<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog(selector) {

        // interop with multilangual 
        if ('' == 'true') {
            _containerSelector = 'div.post-container.active'
        } else {
            _containerSelector = 'div.post-container'
        }

        // init
        var P = $(_containerSelector), a, n, t, l, i, c;
        a = P.find('h1,h2,h3,h4,h5,h6');

        // clean
        $(selector).html('')

        // appending
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#" + $(this).prop('id');
            t = $(this).text();
            c = $('<a href="' + i + '" rel="nofollow">' + t + '</a>');
            l = $('<li class="' + n + '_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function (e) {
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>



<!-- Multi-Lingual -->


<!-- Simple Jekyll Search -->
<script>
    // https://stackoverflow.com/questions/1912501/unescape-html-entities-in-javascript
    function htmlDecode(input) {
        var e = document.createElement('textarea');
        e.innerHTML = input;
        // handle case of empty input
        return e.childNodes.length === 0 ? "" : e.childNodes[0].nodeValue;
    }

    SimpleJekyllSearch({
        searchInput: document.getElementById('search-input'),
        resultsContainer: document.getElementById('search-results'),
        json: '/search.json',
        searchResultTemplate: '<div class="post-preview item"><a href="{url}"><h2 class="post-title">{title}</h2><h3 class="post-subtitle">{subtitle}</h3><hr></a></div>',
        noResultsText: 'No results',
        limit: 50,
        fuzzy: false,
        // a hack to get escaped subtitle unescaped. for some reason, 
        // post.subtitle w/o escape filter nuke entire search.
        templateMiddleware: function (prop, value, template) {
            if (prop === 'subtitle' || prop === 'title') {
                if (value.indexOf("code")) {
                    return htmlDecode(value);
                } else {
                    return value;
                }
            }
        }
    });

    $(document).ready(function () {
        var $searchPage = $('.search-page');
        var $searchOpen = $('.search-icon');
        var $searchClose = $('.search-icon-close');
        var $searchInput = $('#search-input');
        var $body = $('body');

        $searchOpen.on('click', function (e) {
            e.preventDefault();
            $searchPage.toggleClass('search-active');
            var prevClasses = $body.attr('class') || '';
            setTimeout(function () {
                $body.addClass('no-scroll');
            }, 400)

            if ($searchPage.hasClass('search-active')) {
                $searchClose.on('click', function (e) {
                    e.preventDefault();
                    $searchPage.removeClass('search-active');
                    $body.attr('class', prevClasses);  // from closure 
                });
                $searchInput.focus();
            }
        });
    });
</script>
  </body>
</html>
