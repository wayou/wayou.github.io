
<!DOCTYPE html>
<html>
    <head>
        
        <meta charset="utf-8">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="generator" content="Polymer Starter Kit" />
        <title>如何开发一个简单的HTML5 Canvas 小游戏 | 刘哇勇的部落格</title>
        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->
        <!-- Chrome for Android theme color -->
        <meta name="theme-color" content="#303F9F">
        <!-- Web Application Manifest -->
        <link rel="manifest" href="manifest.json">
        <!-- Tile color for Win8 -->
        <meta name="msapplication-TileColor" content="#3372DF">
        <!-- Add to homescreen for Chrome on Android -->
        <meta name="mobile-web-app-capable" content="yes">
        <meta name="application-name" content="刘哇勇的部落格">
        <link rel="icon" sizes="192x192" href="app-icon-192x192.png">
        <!-- Add to homescreen for Safari on iOS -->
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <meta name="apple-mobile-web-app-title" content="刘哇勇的部落格">
        <link rel="apple-touch-icon" href="app-icon-192x192.png">
        <!-- Tile icon for Win8 (144x144) -->
        <meta name="msapplication-TileImage" content="app-icon-192x192.png">
        <!-- rss -->
        
        <link rel="alternative" href="/atom.xml" title="刘哇勇的部落格" type="application/atom+xml">
        
        <!-- favicon -->
        
        <link rel="icon" href="/favicon.ico">
        
        <link rel="stylesheet" href="/css/github-markdown.css" type="text/css">
        <link rel="stylesheet" href="/css/highlight.css" type="text/css">
        <link rel="stylesheet" href="/css/main.css" type="text/css">
        <script src="/polymer/webcomponentsjs/webcomponents-lite.js" type="text/javascript"></script>
        <link rel="import" href="/elements/elements.html">
        <style type="text/css">
        /*style for polymer scroll header*/
          paper-scroll-header-panel {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            background-color: var(--paper-grey-200, #eee);

            /* background for toolbar when it is at its full size */
            --paper-scroll-header-panel-full-header: {
              background-image: url( / );
            };

            /* background for toolbar when it is condensed */
            --paper-scroll-header-panel-condensed-header: {
              /*background-color: var(--paper-deep-orange-500, #ff5722);*/
              background-color: #3F51B5;
            };
          }

        

        </style>
    </head>


<style is="custom-style">

  paper-scroll-header-panel {
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    background-color: var(--paper-grey-200, #eee);

    /* background for toolbar when it is at its full size */
    --paper-scroll-header-panel-full-header: {
      background-image: url( / );
    };

    /* background for toolbar when it is condensed */
    --paper-scroll-header-panel-condensed-header: {
      /*background-color: var(--paper-deep-orange-500, #ff5722);*/
      background-color: #3F51B5;
    };
  }



</style>

<body unresolved class="fullbleed layout vertical">
  <template is="dom-bind" id="app">

    <paper-drawer-panel id="paperDrawerPanel">

       <div drawer>
	<!-- Drawer Toolbar -->
	<paper-toolbar class="tall" id="drawerToolbar">
	  <div class="bottom title">
	  	<span class="paper-font-title"> 刘哇勇的部落格 </span>
	  </div>
	</paper-toolbar>

	<!-- Drawer Content -->
	<paper-menu class="list" attr-for-selected="data-route"  on-iron-select="onMenuSelect">

	  
	    <a href="/">
	        <iron-icon icon="home"></iron-icon>
	        <span>Home</span>
	    </a>
	  
	    <a href="/archives">
	        <iron-icon icon="archive"></iron-icon>
	        <span>Archives</span>
	    </a>
	  
	    <a href="/about">
	        <iron-icon icon="info"></iron-icon>
	        <span>About</span>
	    </a>
	  
	    <a href="/atom.xml">
	        <iron-icon icon="bookmark"></iron-icon>
	        <span>RSS</span>
	    </a>
	  
	 
	</paper-menu>
</div>

      <paper-header-panel main mode="waterfall-tall">

         <paper-scroll-header-panel condenses>

          <paper-toolbar class="tall" id="mainToolbar">

  <!-- index -->
  
  	<paper-icon-button icon="arrow-back" onclick="back(event)"></paper-icon-button>
  

  <div class="flex"></div>
  <!-- <paper-icon-button icon="search"></paper-icon-button> -->

  <!-- Application sub title -->
  <!-- index -->
  
	  <div class="bottom title"> 如何开发一个简单的HTML5 Canvas 小游戏 </div>
  
  
</paper-toolbar>

<!-- Main Content -->
<div class="content">

  <!-- index -->
  
    <paper-material class="markdown-body">
      <p><blockquote>
<p>原文：<a href="http://www.lostdecadegames.com/how-to-make-a-simple-html5-canvas-game/" target="_blank" rel="external">How to make a simple HTML5 Canvas game</a></p>
</blockquote>
<p>想要快速上手HTML5 Canvas小游戏开发？下面通过一个例子来进行手把手教学。（如果你怀疑我的资历， <a href="http://www.wizardslizard.com/" target="_blank" rel="external">A Wizard’s Lizard</a>这个游戏的半数以上开发是由我完成的）</p>
<a id="more"></a>
<p>我们直接来看源码里的<a href="https://github.com/lostdecade/simple_canvas_game/blob/master/js/game.js" target="_blank" rel="external">game.js</a>,当然你也可以<a href="http://www.lostdecadegames.com/demos/simple_canvas_game/" target="_blank" rel="external">在线体验</a>一下游戏先。</p>
<h1 id="游戏截图">游戏截图</h1><p><img src="/asset/posts/how-to-make-a-simple-html5-canvas-game-zh/screenshot.jpg" alt="游戏截图"></p>
<h1 id="创建画布">创建画布</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create the canvas</span></span><br><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">"canvas"</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">"2d"</span>);</span><br><span class="line">canvas.width = <span class="number">512</span>;</span><br><span class="line">canvas.height = <span class="number">480</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(canvas);</span><br></pre></td></tr></table></figure>
<p>首先我们需要创建一张<a href="https://developer.mozilla.org/en/canvas_tutorial" target="_blank" rel="external">画布</a>作为游戏的舞台。这里通过JS代码而不是直接在HTML里写一个<code>&lt;canvas&gt;</code>元素目的是要说明代码创建也是很方便的。有了画布后就可以获得它的上下文来进行绘图了。然后我们还设置了画布大小，最后将其添加到页面上。</p>
<h1 id="准备图片">准备图片</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 背景图片</span></span><br><span class="line"><span class="keyword">var</span> bgReady = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> bgImage = <span class="keyword">new</span> Image();</span><br><span class="line">bgImage.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    bgReady = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line">bgImage.src = <span class="string">"images/background.png"</span>;</span><br></pre></td></tr></table></figure>
<p>游戏嘛少不了图片的，所以我们先加载一些图片先。简便起见，这里仅创建简单的图片对象，而不是专门写一个类或者Helper来做图片加载。<code>bgReady</code>这个变量用来标识图片是否已经加载完成从而可以放心地使用了，因为如果在<a href="http://stackoverflow.com/questions/2923564/uncaught-error-index-size-err" target="_blank" rel="external">图片加载未完成情况下进行绘制是会报错</a>的。</p>
<p>整个游戏中需要用到的三张图片：<a href="https://github.com/lostdecade/simple_canvas_game/blob/master/images/background.png" target="_blank" rel="external">背景</a>，<a href="https://github.com/lostdecade/simple_canvas_game/blob/master/images/hero.png" target="_blank" rel="external">英雄</a>及<a href="https://github.com/lostdecade/simple_canvas_game/blob/master/images/monster.png" target="_blank" rel="external">怪物</a>我们都用上面的方法来处理。</p>
<h1 id="游戏对象">游戏对象</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 游戏对象</span></span><br><span class="line"><span class="keyword">var</span> hero = &#123;</span><br><span class="line">    speed: <span class="number">256</span>, <span class="comment">// 每秒移动的像素</span></span><br><span class="line">    x: <span class="number">0</span>,</span><br><span class="line">    y: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> monster = &#123;</span><br><span class="line">    x: <span class="number">0</span>,</span><br><span class="line">    y: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> monstersCaught = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>现在定义一些对象将在后面用到。我们的<code>英雄</code>有一个<code>speed</code>属性用来控制他每秒移动多少像素。<code>怪物</code>游戏过程中不会移动，所以只有坐标属性就够了。<code>monstersCaught</code>则用来存储怪物被捉住的次数。</p>
<h1 id="处理用户的输入">处理用户的输入</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 处理按键</span></span><br><span class="line"><span class="keyword">var</span> keysDown = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">addEventListener(<span class="string">"keydown"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    keysDown[e.keyCode] = <span class="literal">true</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">addEventListener(<span class="string">"keyup"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> keysDown[e.keyCode];</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>现在开始处理用户的输入(对初次接触游戏开发的前端同学来说，这部分开始可能就需要一些脑力了)。在前端开发中，一般是用户触发了点击事件然后才去执行动画或发起异步请求之类的，但这里我们希望游戏的逻辑能够更加紧凑同时又要及时响应输入。所以我们就把用户的输入先保存下来而不是立即响应。</p>
<p>为此，我们用<code>keysDown</code>这个对象来保存用户按下的键值(<code>keyCode</code>)，如果按下的键值在这个对象里，那么我们就做相应处理。</p>
<h1 id="开始一轮游戏">开始一轮游戏</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当用户抓住一只怪物后开始新一轮游戏</span></span><br><span class="line"><span class="keyword">var</span> reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    hero.x = canvas.width / <span class="number">2</span>;</span><br><span class="line">    hero.y = canvas.height / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新的怪物随机放置到界面上</span></span><br><span class="line">    monster.x = <span class="number">32</span> + (<span class="built_in">Math</span>.random() * (canvas.width - <span class="number">64</span>));</span><br><span class="line">    monster.y = <span class="number">32</span> + (<span class="built_in">Math</span>.random() * (canvas.height - <span class="number">64</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>reset</code>方法用于开始新一轮和游戏，在这个方法里我们将英雄放回画布中心同时将怪物放到一个随机的地方。</p>
<h1 id="更新对象">更新对象</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新游戏对象的属性</span></span><br><span class="line"><span class="keyword">var</span> update = <span class="function"><span class="keyword">function</span> (<span class="params">modifier</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">38</span> <span class="keyword">in</span> keysDown) &#123; <span class="comment">// 用户按的是↑</span></span><br><span class="line">        hero.y -= hero.speed * modifier;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">40</span> <span class="keyword">in</span> keysDown) &#123; <span class="comment">// 用户按的是↓</span></span><br><span class="line">        hero.y += hero.speed * modifier;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">37</span> <span class="keyword">in</span> keysDown) &#123; <span class="comment">// 用户按的是←</span></span><br><span class="line">        hero.x -= hero.speed * modifier;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">39</span> <span class="keyword">in</span> keysDown) &#123; <span class="comment">// 用户按的是→</span></span><br><span class="line">        hero.x += hero.speed * modifier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 英雄与怪物碰到了么？</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">        hero.x &lt;= (monster.x + <span class="number">32</span>)</span><br><span class="line">        &amp;&amp; monster.x &lt;= (hero.x + <span class="number">32</span>)</span><br><span class="line">        &amp;&amp; hero.y &lt;= (monster.y + <span class="number">32</span>)</span><br><span class="line">        &amp;&amp; monster.y &lt;= (hero.y + <span class="number">32</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">        ++monstersCaught;</span><br><span class="line">        reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这就是游戏中用于更新画面的<code>update</code>函数，会被规律地重复调用。首先它负责检查用户当前按住的是中方向键，然后将英雄往相应方向移动。</p>
<p>有点费脑力的或许是这个传入的<code>modifier</code> 变量。你可以在<code>main</code> 方法里看到它的来源，但这里还是有必要详细解释一下。它是基于1开始且随时间变化的一个因子。例如1秒过去了，它的值就是1，英雄的速度将会乘以1，也就是每秒移动256像素；如果半秒钟则它的值为0.5，英雄的速度就乘以0.5也就是说这半秒内英雄以正常速度一半的速度移动。理论上说因为这个<code>update</code> 方法被调用的非常快且频繁，所以<code>modifier</code>的值会很小，但有了这一因子后，不管我们的代码跑得快慢，都能够保证英雄的移动速度是恒定的。</p>
<p>现在英雄的移动已经是基于用户的输入了，接下来该检查移动过程中所触发的事件了，也就是英雄与怪物相遇。这就是本游戏的胜利点，<code>monstersCaught</code> +1然后重新开始新一轮。</p>
<h1 id="渲染物体">渲染物体</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 画出所有物体</span></span><br><span class="line"><span class="keyword">var</span> render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bgReady) &#123;</span><br><span class="line">        ctx.drawImage(bgImage, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (heroReady) &#123;</span><br><span class="line">        ctx.drawImage(heroImage, hero.x, hero.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (monsterReady) &#123;</span><br><span class="line">        ctx.drawImage(monsterImage, monster.x, monster.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计分</span></span><br><span class="line">    ctx.fillStyle = <span class="string">"rgb(250, 250, 250)"</span>;</span><br><span class="line">    ctx.font = <span class="string">"24px Helvetica"</span>;</span><br><span class="line">    ctx.textAlign = <span class="string">"left"</span>;</span><br><span class="line">    ctx.textBaseline = <span class="string">"top"</span>;</span><br><span class="line">    ctx.fillText(<span class="string">"Monsterrs caught: "</span> + monstersCaught, <span class="number">32</span>, <span class="number">32</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>之前的工作都是枯燥的，直到你把所有东西画出来之后。首先当然是<a href="https://developer.mozilla.org/en/Canvas_tutorial/Using_images" target="_blank" rel="external">把背景图画出来</a>。然后如法炮制将英雄和怪物也画出来。这个过程中的顺序是有讲究的，因为后画的物体会覆盖之前的物体。</p>
<p>这之后我们改变了一下<code>Canvas</code>的绘图上下文的样式并调用<code>fillText</code>来绘制文字，也就是记分板那一部分。本游戏没有其他复杂的动画效果和打斗场面，绘制部分大功告成！</p>
<h1 id="主循环函数">主循环函数</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 游戏主函数</span></span><br><span class="line"><span class="keyword">var</span> main = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">var</span> delta = now - then;</span><br><span class="line"></span><br><span class="line">    update(delta / <span class="number">1000</span>);</span><br><span class="line">    render();</span><br><span class="line"></span><br><span class="line">    then = now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 立即调用主函数</span></span><br><span class="line">    requestAnimationFrame(main);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的主函数控制了整个游戏的流程。先是拿到当前的时间用来计算时间差（距离上次主函数被调用时过了多少毫秒）。得到<code>modifier</code>后除以1000(也就是1秒中的毫秒数)再传入<code>update</code>函数。最后调用<code>render</code> 函数并且将本次的时间保存下来。</p>
<p>关于游戏中循环更新画面的讨论可参见「<a href="http://www.html5rocks.com/en/tutorials/casestudies/onslaught.html#toc-the-game-loop" target="_blank" rel="external"> Onslaught! Arena Case Study</a>」。</p>
<h1 id="关于循环的进一步解释">关于循环的进一步解释</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// requestAnimationFrame 的浏览器兼容性处理</span></span><br><span class="line"><span class="keyword">var</span> w = <span class="built_in">window</span>;</span><br><span class="line">requestAnimationFrame = w.requestAnimationFrame || w.webkitRequestAnimationFrame || w.msRequestAnimationFrame || w.mozRequestAnimationFrame;</span><br></pre></td></tr></table></figure>
<p><em>如果你不是完全理解上面的代码也没关系，我只是觉得拿出来解释一下总是极好的</em></p>
<p>为了循环地调用<code>main</code>函数，本游戏之前用的是<code>setInterval</code>。但现今已经有了更好的方法那就是<code>requestAnimationFrame</code>。使用新方法就不得不考虑浏览器兼容性。上面的<a href="https://en.wikipedia.org/wiki/Polyfill" target="_blank" rel="external">垫片</a>就是出于这样的考虑，它是<a href="http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/" target="_blank" rel="external">Paul Irish 博客原版</a>的一个简化版本。</p>
<h1 id="启动游戏！">启动游戏！</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 少年，开始游戏吧！</span></span><br><span class="line"><span class="keyword">var</span> then = <span class="built_in">Date</span>.now();</span><br><span class="line">reset();</span><br><span class="line">main();</span><br></pre></td></tr></table></figure>
<p>总算完成了，这是本游戏最后一段代码了。先是设置一个初始的时间变量<code>then</code>用于首先运行<code>main</code>函数使用。然后调用 <code>reset</code> 函数来开始新一轮游戏（如果你还记得的话，这个函数的作用是将英雄放到画面中间同时将怪物放到随机的地方以方便英雄去捉它）。</p>
<p>到此，相信你已经掌握了开发一个简单H5小游戏需要的基本功了。<a href="http://www.lostdecadegames.com/demos/simple_canvas_game/" target="_blank" rel="external">玩玩这个游戏</a>或者<a href="https://github.com/lostdecade/simple_canvas_game" target="_blank" rel="external">下载代码</a>自己研究研究吧 :)</p>
</p>
    </paper-material>
	  <paper-material>
      
  
   <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="_posts/2014-11-02-how-to-make-a-simple-html5-canvas-game-zh.md" data-title="如何开发一个简单的HTML5 Canvas 小游戏" data-url="http://wayou.github.io/2014/11/02/how-to-make-a-simple-html5-canvas-game-zh/"></div>
    <!-- 多说评论框 end -->
   <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'wayouliu'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  


		</paper-material>
  

  <!-- pagination -->
  

  
<footer>
	<p>由 <a href="https://hexo.io">hexo</a> 强力驱动 | 搭载 <a href="https://github.com/wayou/hexo-theme-polymer">polymer</a> 主题 </p>
	<p>&copy;2015 copy left or right? </p>
</footer>

<script src="/js/main.js" type="text/javascript"></script>

<!-- 百度统计 -->

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?392796d51567e848aebf813b65cb8656";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<!-- 谷歌统计 -->


</div>






        </paper-scroll-header-panel>

      </paper-header-panel>

    </paper-drawer-panel>

  </template>

</body>

</html>